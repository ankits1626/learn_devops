# 1.3 kubectl Essentials

> Master the commands you'll use every day through hands-on labs

---

## What is kubectl?

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         kubectl                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   You  ──────▶  kubectl  ──────▶  API Server  ──────▶  Cluster          │
│                                                                         │
│   kubectl is the CLI that talks to the Kubernetes API.                  │
│   Every action in K8s goes through the API server.                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Lab 1: Basic CRUD Operations

### What You'll Learn

- Create, Read, Update, Delete resources
- The most fundamental kubectl commands

### Setup: Create a test pod

```bash
kubectl run lab-pod --image=nginx:1.25
```

### Step 1: CREATE (apply/create/run)

```bash
# Imperative: create directly
kubectl run nginx-imperative --image=nginx:1.25

# Declarative: create from YAML (preferred)
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: nginx-declarative
spec:
  containers:
    - name: nginx
      image: nginx:1.25
EOF

# Create from file
kubectl apply -f /tmp/my-pod.yaml

# Create namespace
kubectl create namespace test-ns
```

### Step 2: READ (get/describe/logs)

```bash
# List pods
kubectl get pods

# List with more info
kubectl get pods -o wide

# List all resources
kubectl get all

# Describe (detailed info + events)
kubectl describe pod lab-pod

# Get YAML
kubectl get pod lab-pod -o yaml

# Get JSON
kubectl get pod lab-pod -o json
```

### Step 3: UPDATE (apply/edit/patch)

```bash
# Edit in editor (opens vim/nano)
kubectl edit pod lab-pod

# Apply updated YAML
kubectl apply -f updated-pod.yaml

# Patch specific field
kubectl patch pod lab-pod -p '{"metadata":{"labels":{"env":"test"}}}'
```

### Step 4: DELETE

```bash
# Delete by name
kubectl delete pod lab-pod

# Delete from file
kubectl delete -f my-pod.yaml

# Delete with label selector
kubectl delete pods -l app=test

# Delete all pods in namespace
kubectl delete pods --all

# Force delete (stuck pods)
kubectl delete pod stuck-pod --force --grace-period=0
```

### Cleanup

```bash
kubectl delete pod nginx-imperative nginx-declarative 2>/dev/null
kubectl delete namespace test-ns 2>/dev/null
```

---

## Lab 2: Output Formats and Filtering

### What You'll Learn

- Different output formats (-o)
- JSONPath for extracting specific fields
- Filtering with labels and fields

### Setup

```bash
# Create test pods
kubectl run web1 --image=nginx:1.25 --labels="app=web,tier=frontend"
kubectl run web2 --image=nginx:1.25 --labels="app=web,tier=backend"
kubectl run db1 --image=nginx:1.25 --labels="app=db,tier=backend"

# Wait for running
kubectl wait --for=condition=Ready pod/web1 pod/web2 pod/db1 --timeout=60s
```

### Step 1: Output formats

```bash
# Default table
kubectl get pods

# Wide - more columns
kubectl get pods -o wide

# YAML
kubectl get pods -o yaml

# JSON
kubectl get pods -o json

# Just names
kubectl get pods -o name
# Output:
# pod/web1
# pod/web2
# pod/db1

# Custom columns
kubectl get pods -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,IP:.status.podIP

# Custom columns from file
cat << 'EOF' > /tmp/columns.txt
NAME          STATUS           IP
.metadata.name .status.phase   .status.podIP
EOF
kubectl get pods -o custom-columns-file=/tmp/columns.txt
```

### Step 2: JSONPath - extract specific fields

```bash
# Get all pod names
kubectl get pods -o jsonpath='{.items[*].metadata.name}'
# Output: web1 web2 db1

# Get with newlines
kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'

# Get pod IPs
kubectl get pods -o jsonpath='{.items[*].status.podIP}'

# Get specific pod's IP
kubectl get pod web1 -o jsonpath='{.status.podIP}'

# Combine fields
kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.podIP}{"\n"}{end}'
```

### Step 3: Label selectors

```bash
# Select by label
kubectl get pods -l app=web
# Output: web1, web2

kubectl get pods -l tier=backend
# Output: web2, db1

# Multiple labels (AND)
kubectl get pods -l app=web,tier=frontend
# Output: web1

# Label exists
kubectl get pods -l 'app'

# Label not equal
kubectl get pods -l 'app!=db'

# Show labels
kubectl get pods --show-labels

# Add label to existing pod
kubectl label pod web1 environment=production

# Remove label
kubectl label pod web1 environment-
```

### Step 4: Field selectors

```bash
# Select by status
kubectl get pods --field-selector=status.phase=Running

# Select by name
kubectl get pods --field-selector=metadata.name=web1

# Combine with label selector
kubectl get pods -l app=web --field-selector=status.phase=Running
```

### Cleanup

```bash
kubectl delete pod web1 web2 db1
```

---

## Lab 3: Logs and Debugging

### What You'll Learn

- View container logs
- Debug running containers
- Access containers with exec

### Setup

```bash
# Create a pod that generates logs
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: log-generator
spec:
  containers:
    - name: logger
      image: busybox:1.36
      command: ["/bin/sh", "-c"]
      args:
        - |
          i=0
          while true; do
            echo "$(date) - Log message $i"
            i=$((i+1))
            sleep 2
          done
EOF

# Wait for it
kubectl wait --for=condition=Ready pod/log-generator --timeout=60s
```

### Step 1: View logs

```bash
# Basic logs
kubectl logs log-generator

# Follow logs (stream)
kubectl logs -f log-generator
# Press Ctrl+C to stop

# Last N lines
kubectl logs --tail=5 log-generator

# Logs since time
kubectl logs --since=1m log-generator

# Logs since timestamp
kubectl logs --since-time="2024-01-01T00:00:00Z" log-generator

# Previous container logs (if restarted)
kubectl logs log-generator --previous
```

### Step 2: Multi-container logs

```bash
# Create multi-container pod
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: multi-container
spec:
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "while true; do echo 'APP log'; sleep 3; done"]
    - name: sidecar
      image: busybox:1.36
      command: ["/bin/sh", "-c", "while true; do echo 'SIDECAR log'; sleep 3; done"]
EOF

kubectl wait --for=condition=Ready pod/multi-container --timeout=60s

# Logs from specific container
kubectl logs multi-container -c app
kubectl logs multi-container -c sidecar

# Logs from all containers
kubectl logs multi-container --all-containers=true

# Follow all containers with prefix
kubectl logs -f multi-container --all-containers=true --prefix=true
```

### Step 3: exec - Run commands in containers

```bash
# Run single command
kubectl exec log-generator -- date
kubectl exec log-generator -- cat /etc/os-release
kubectl exec log-generator -- ls -la /

# Interactive shell
kubectl exec -it log-generator -- /bin/sh
# You're now inside the container!
# Run: hostname, pwd, env, exit

# Exec in specific container
kubectl exec -it multi-container -c app -- /bin/sh

# Non-interactive command with output
kubectl exec log-generator -- ps aux
```

### Step 4: Debug with describe and events

```bash
# Detailed pod info
kubectl describe pod log-generator

# Just events
kubectl get events --sort-by=.lastTimestamp

# Events for specific pod
kubectl get events --field-selector involvedObject.name=log-generator

# Watch events
kubectl get events -w
```

### Cleanup

```bash
kubectl delete pod log-generator multi-container
```

---

## Lab 4: Port Forwarding and Proxying

### What You'll Learn

- Access pod ports locally
- Proxy to the API server

### Setup

```bash
kubectl run nginx-web --image=nginx:1.25 --port=80
kubectl wait --for=condition=Ready pod/nginx-web --timeout=60s
```

### Step 1: Port forward to a pod

```bash
# Forward local 8080 to pod 80
kubectl port-forward pod/nginx-web 8080:80 &

# Test it
curl http://localhost:8080

# Stop port-forward
kill %1

# Forward to random local port
kubectl port-forward pod/nginx-web :80 &
# Note the assigned port in output
kill %1

# Forward multiple ports
kubectl port-forward pod/nginx-web 8080:80 8443:443 &
kill %1
```

### Step 2: Port forward to a service

```bash
# Create a service
kubectl expose pod nginx-web --port=80 --name=nginx-svc

# Forward to service
kubectl port-forward svc/nginx-svc 8080:80 &
curl http://localhost:8080
kill %1
```

### Step 3: kubectl proxy (API access)

```bash
# Start proxy to API server
kubectl proxy --port=8001 &

# Access API
curl http://localhost:8001/api/v1/namespaces/default/pods

# Access pod through API
curl http://localhost:8001/api/v1/namespaces/default/pods/nginx-web

# Stop proxy
kill %1
```

### Cleanup

```bash
kubectl delete pod nginx-web
kubectl delete svc nginx-svc
```

---

## Lab 5: Working with Namespaces

### What You'll Learn

- Create and use namespaces
- Switch default namespace
- Work across namespaces

### Step 1: Create namespaces

```bash
# Create namespace
kubectl create namespace dev
kubectl create namespace staging
kubectl create namespace prod

# List namespaces
kubectl get namespaces
# or
kubectl get ns
```

### Step 2: Create resources in namespaces

```bash
# Create pod in specific namespace
kubectl run nginx-dev --image=nginx:1.25 -n dev
kubectl run nginx-staging --image=nginx:1.25 -n staging
kubectl run nginx-prod --image=nginx:1.25 -n prod

# List pods in namespace
kubectl get pods -n dev
kubectl get pods -n staging
kubectl get pods -n prod

# List pods in all namespaces
kubectl get pods -A
# or
kubectl get pods --all-namespaces
```

### Step 3: Set default namespace

```bash
# Check current context
kubectl config current-context

# Set default namespace for current context
kubectl config set-context --current --namespace=dev

# Now kubectl commands default to 'dev'
kubectl get pods
# Shows pods in dev namespace

# Reset to default
kubectl config set-context --current --namespace=default
```

### Step 4: kubens (optional but useful)

```bash
# If you have kubens installed (brew install kubectx)
kubens           # List namespaces
kubens dev       # Switch to dev
kubens -         # Switch to previous
```

### Cleanup

```bash
kubectl delete namespace dev staging prod
```

---

## Lab 6: Context and Config

### What You'll Learn

- Manage multiple clusters
- Switch contexts
- View and modify kubeconfig

### Step 1: View current config

```bash
# View entire config
kubectl config view

# View current context
kubectl config current-context

# List all contexts
kubectl config get-contexts

# View clusters
kubectl config get-clusters
```

### Step 2: Work with contexts

```bash
# Switch context
kubectl config use-context <context-name>

# Create new context (pointing to existing cluster)
kubectl config set-context my-dev-context \
  --cluster=kind-kind \
  --namespace=default \
  --user=kind-kind

# Use the new context
kubectl config use-context my-dev-context

# Rename context
kubectl config rename-context my-dev-context dev-context

# Delete context
kubectl config delete-context dev-context
```

### Step 3: kubectx (optional but useful)

```bash
# If you have kubectx installed (brew install kubectx)
kubectx           # List contexts
kubectx my-ctx    # Switch to my-ctx
kubectx -         # Switch to previous
```

---

## Lab 7: Dry Run and Diff

### What You'll Learn

- Test changes before applying
- See what would change
- Generate YAML templates

### Step 1: Dry run modes

```bash
# Client-side dry run (basic validation)
kubectl run test-pod --image=nginx:1.25 --dry-run=client -o yaml

# Server-side dry run (full validation)
kubectl run test-pod --image=nginx:1.25 --dry-run=server -o yaml

# Apply with dry run
cat << 'EOF' > /tmp/test-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  containers:
    - name: nginx
      image: nginx:1.25
EOF

kubectl apply -f /tmp/test-pod.yaml --dry-run=server
```

### Step 2: Diff before apply

```bash
# Create a pod
kubectl apply -f /tmp/test-pod.yaml

# Modify the file
cat << 'EOF' > /tmp/test-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  labels:
    app: web
spec:
  containers:
    - name: nginx
      image: nginx:1.26
EOF

# See what would change
kubectl diff -f /tmp/test-pod.yaml

# Now apply
kubectl apply -f /tmp/test-pod.yaml

kubectl delete pod test-pod
```

### Step 3: Generate YAML templates

```bash
# Generate pod YAML
kubectl run nginx --image=nginx:1.25 --dry-run=client -o yaml

# Generate with labels and port
kubectl run nginx --image=nginx:1.25 \
  --labels="app=web,tier=frontend" \
  --port=80 \
  --dry-run=client -o yaml

# Generate deployment YAML
kubectl create deployment nginx --image=nginx:1.25 --dry-run=client -o yaml

# Generate service YAML
kubectl create service clusterip nginx --tcp=80:80 --dry-run=client -o yaml

# Generate configmap YAML
kubectl create configmap app-config \
  --from-literal=key1=value1 \
  --dry-run=client -o yaml

# Generate secret YAML
kubectl create secret generic app-secret \
  --from-literal=password=secret123 \
  --dry-run=client -o yaml
```

---

## Lab 8: Watch and Wait

### What You'll Learn

- Watch resources in real-time
- Wait for conditions
- Monitor rollouts

### Step 1: Watch resources

```bash
# Watch pods
kubectl get pods -w

# In another terminal, create a pod
kubectl run watch-demo --image=nginx:1.25

# You'll see the pod go through:
# Pending → ContainerCreating → Running

# Watch with timestamp
kubectl get pods -w --output-watch-events

# Stop with Ctrl+C
```

### Step 2: Wait for conditions

```bash
# Wait for pod to be ready
kubectl run wait-demo --image=nginx:1.25
kubectl wait --for=condition=Ready pod/wait-demo --timeout=60s

# Wait for pod to be deleted
kubectl delete pod wait-demo &
kubectl wait --for=delete pod/wait-demo --timeout=60s

# Wait for multiple pods
kubectl run p1 --image=nginx:1.25
kubectl run p2 --image=nginx:1.25
kubectl wait --for=condition=Ready pod/p1 pod/p2 --timeout=60s

kubectl delete pod p1 p2
```

### Step 3: Watch events

```bash
# Watch all events
kubectl get events -w

# Watch events sorted by time
kubectl get events --sort-by=.lastTimestamp

# Watch events for specific resource
kubectl get events --field-selector involvedObject.name=my-pod -w
```

---

## Quick Reference Card

```bash
# ─────────────────────────────────────────────────────────────
# ESSENTIAL COMMANDS
# ─────────────────────────────────────────────────────────────

# CREATE
kubectl apply -f <file>              # Create/update from YAML
kubectl run <name> --image=<img>     # Quick pod creation
kubectl create namespace <name>      # Create namespace

# READ
kubectl get <resource>               # List resources
kubectl get <resource> -o wide       # More columns
kubectl get <resource> -o yaml       # Full YAML
kubectl describe <resource> <name>   # Detailed info
kubectl logs <pod>                   # View logs
kubectl logs -f <pod>                # Follow logs

# UPDATE
kubectl apply -f <file>              # Apply changes
kubectl edit <resource> <name>       # Edit in editor
kubectl label <resource> <name> k=v  # Add label
kubectl patch <resource> <name> -p   # Patch specific field

# DELETE
kubectl delete <resource> <name>     # Delete by name
kubectl delete -f <file>             # Delete from file
kubectl delete <resource> -l k=v     # Delete by label

# DEBUG
kubectl exec -it <pod> -- /bin/sh    # Shell into pod
kubectl port-forward <pod> 8080:80   # Forward port
kubectl describe <resource> <name>   # Check events
kubectl get events                   # Cluster events

# ─────────────────────────────────────────────────────────────
# OUTPUT FORMATS
# ─────────────────────────────────────────────────────────────

-o wide                              # More columns
-o yaml                              # YAML format
-o json                              # JSON format
-o name                              # Just names
-o jsonpath='{...}'                  # Extract fields
-o custom-columns=NAME:...,COL:...   # Custom table

# ─────────────────────────────────────────────────────────────
# FILTERING
# ─────────────────────────────────────────────────────────────

-l app=web                           # Label selector
-l 'app in (web,api)'                # Set selector
-l 'app!=web'                        # Not equal
--field-selector status.phase=Running # Field selector
-A                                   # All namespaces
-n <namespace>                       # Specific namespace

# ─────────────────────────────────────────────────────────────
# USEFUL FLAGS
# ─────────────────────────────────────────────────────────────

--dry-run=client                     # Test locally
--dry-run=server                     # Test on server
-w, --watch                          # Watch for changes
--tail=N                             # Last N log lines
--since=1h                           # Logs since duration
-c <container>                       # Specific container
--all-containers                     # All containers
```

---

## Key Takeaways

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      WHAT YOU LEARNED                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Lab 1: CRUD - apply, get, describe, delete                             │
│  Lab 2: Output formats - -o wide/yaml/json/jsonpath                     │
│  Lab 3: Logs & Debug - logs, exec, describe, events                     │
│  Lab 4: Port forward - access pods locally                              │
│  Lab 5: Namespaces - -n, -A, set-context                                │
│  Lab 6: Contexts - manage multiple clusters                             │
│  Lab 7: Dry run & diff - test before applying                           │
│  Lab 8: Watch & wait - monitor in real-time                             │
│                                                                         │
│  Pro tips:                                                              │
│  • Use --dry-run=client -o yaml to generate templates                   │
│  • Use kubectl explain to understand fields                             │
│  • Use -w to watch changes in real-time                                 │
│  • Use kubectl describe for debugging (check Events!)                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Next Up

[1.4 Pod Lifecycle](1.4_pod_lifecycle.md) — Understand pod states and transitions

---

*Chapter 1.3 of Kubernetes 101: From Zero to Production*
