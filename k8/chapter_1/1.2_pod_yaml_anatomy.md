# 1.2 Pod YAML Anatomy

> Learn pod manifests by building them piece by piece

---

## The Universal K8s YAML Structure

Every Kubernetes resource follows this pattern:

```yaml
apiVersion: <version>       # Which K8s API to use
kind: <resource-type>       # What you're creating
metadata:                   # Identity & organization
  name: <unique-name>
spec:                       # Desired state (what you want)
  # Resource-specific config
```

We'll learn each section through hands-on labs.

---

## Lab 1: Minimal Pod - The Bare Essentials

### What You'll Learn
- The 4 required fields for any pod

### Step 1: Create the minimal pod

```bash
cat << 'EOF' > /tmp/minimal-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: minimal-pod
spec:
  containers:
    - name: nginx
      image: nginx:1.25
EOF
```

**That's it!** Only 4 things are truly required:
- `apiVersion: v1` — Pods use the core API
- `kind: Pod` — Resource type
- `metadata.name` — Unique identifier
- `spec.containers[]` — At least one container with name + image

### Step 2: Apply and verify

```bash
kubectl apply -f /tmp/minimal-pod.yaml
kubectl get pods
kubectl describe pod minimal-pod
```

### Step 3: Clean up

```bash
kubectl delete pod minimal-pod
```

---

## Lab 2: Labels & Selectors - Organizing Your Pods

### What You'll Learn
- How labels work
- How to select pods by labels
- Labels vs Annotations

### Step 1: Create pods with labels

```bash
# Create three pods with different labels
cat << 'EOF' > /tmp/labeled-pods.yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-frontend
  labels:
    app: web
    tier: frontend
    environment: production
spec:
  containers:
    - name: nginx
      image: nginx:1.25
---
apiVersion: v1
kind: Pod
metadata:
  name: web-backend
  labels:
    app: web
    tier: backend
    environment: production
spec:
  containers:
    - name: nginx
      image: nginx:1.25
---
apiVersion: v1
kind: Pod
metadata:
  name: web-backend-dev
  labels:
    app: web
    tier: backend
    environment: development
spec:
  containers:
    - name: nginx
      image: nginx:1.25
EOF

kubectl apply -f /tmp/labeled-pods.yaml
```

### Step 2: Select pods by labels

```bash
# Get all pods (should see 3)
kubectl get pods

# Select by single label
kubectl get pods -l app=web
# Output: all 3 pods

# Select by tier
kubectl get pods -l tier=frontend
# Output: only web-frontend

kubectl get pods -l tier=backend
# Output: web-backend, web-backend-dev

# Select by multiple labels (AND)
kubectl get pods -l tier=backend,environment=production
# Output: only web-backend

# Select by label existence
kubectl get pods -l 'environment'
# Output: all pods that HAVE the environment label

# Select by inequality
kubectl get pods -l 'environment!=production'
# Output: only web-backend-dev

# Show labels in output
kubectl get pods --show-labels
```

### Step 3: Understanding Labels vs Annotations

```bash
# Create pod with both labels and annotations
cat << 'EOF' > /tmp/annotated-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: annotated-pod
  labels:
    app: demo              # For SELECTION (Services, kubectl -l)
    version: v1.0.0
  annotations:
    description: "Demo pod showing annotations"   # For METADATA
    owner: "team-platform"
    prometheus.io/scrape: "true"                  # Tool configuration
spec:
  containers:
    - name: nginx
      image: nginx:1.25
EOF

kubectl apply -f /tmp/annotated-pod.yaml

# View annotations
kubectl describe pod annotated-pod | grep -A5 Annotations

# You CANNOT select by annotation!
# kubectl get pods -l description="Demo pod"  # This WON'T work
```

**Key difference:**
| Labels | Annotations |
|--------|-------------|
| For selection & grouping | For metadata & documentation |
| Used by Services, Deployments | Used by tools, humans |
| Max 63 chars | Up to 256KB |

### Step 4: Clean up

```bash
kubectl delete pod web-frontend web-backend web-backend-dev annotated-pod
```

---

## Lab 3: Container Configuration - Ports, Commands, Working Directory

### What You'll Learn
- Container ports (documentation only!)
- Overriding command and args
- Setting working directory

### Step 1: Understanding containerPort

```bash
cat << 'EOF' > /tmp/ports-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: ports-demo
spec:
  containers:
    - name: nginx
      image: nginx:1.25
      ports:
        - name: http           # Optional: name the port
          containerPort: 80    # Documentation only!
          protocol: TCP        # TCP (default) or UDP
EOF

kubectl apply -f /tmp/ports-demo.yaml

# The port is NOT exposed! It's just documentation.
# You still need a Service or port-forward to access it.

# Port-forward to access
kubectl port-forward pod/ports-demo 8080:80 &
curl http://localhost:8080
kill %1

kubectl delete pod ports-demo
```

**Important:** `containerPort` does NOT expose anything. It's documentation for humans and tools.

### Step 2: Overriding command and args

```bash
# Default: nginx runs its default command
# Let's override it

cat << 'EOF' > /tmp/command-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: command-demo
spec:
  containers:
    - name: busybox
      image: busybox:1.36

      # command = ENTRYPOINT in Docker
      command: ["/bin/sh"]

      # args = CMD in Docker
      args: ["-c", "echo 'Hello from K8s!' && sleep 3600"]
EOF

kubectl apply -f /tmp/command-demo.yaml

# Check logs
kubectl logs command-demo
# Output: Hello from K8s!

# The container is sleeping, so it stays running
kubectl get pods command-demo

kubectl delete pod command-demo
```

### Step 3: Working directory

```bash
cat << 'EOF' > /tmp/workdir-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: workdir-demo
spec:
  containers:
    - name: busybox
      image: busybox:1.36
      workingDir: /tmp
      command: ["/bin/sh", "-c", "pwd && sleep 3600"]
EOF

kubectl apply -f /tmp/workdir-demo.yaml
kubectl logs workdir-demo
# Output: /tmp

kubectl delete pod workdir-demo
```

---

## Lab 4: Environment Variables

### What You'll Learn
- Static environment variables
- Environment from Pod metadata
- Environment from ConfigMap and Secret

### Step 1: Static environment variables

```bash
cat << 'EOF' > /tmp/env-static.yaml
apiVersion: v1
kind: Pod
metadata:
  name: env-static
spec:
  containers:
    - name: busybox
      image: busybox:1.36
      command: ["/bin/sh", "-c", "env | grep MY_ && sleep 3600"]
      env:
        - name: MY_VAR
          value: "Hello World"
        - name: MY_NUMBER
          value: "42"              # Always strings in YAML!
        - name: MY_MULTILINE
          value: |
            line1
            line2
EOF

kubectl apply -f /tmp/env-static.yaml
kubectl logs env-static
# Output:
# MY_VAR=Hello World
# MY_NUMBER=42
# MY_MULTILINE=line1
# line2

kubectl delete pod env-static
```

### Step 2: Environment from Pod metadata (Downward API)

```bash
cat << 'EOF' > /tmp/env-metadata.yaml
apiVersion: v1
kind: Pod
metadata:
  name: env-metadata
  labels:
    app: demo
spec:
  containers:
    - name: busybox
      image: busybox:1.36
      command: ["/bin/sh", "-c", "env | sort && sleep 3600"]
      env:
        # Pod name
        - name: MY_POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name

        # Pod namespace
        - name: MY_POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace

        # Pod IP
        - name: MY_POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP

        # Node name
        - name: MY_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName

        # A specific label
        - name: MY_APP_LABEL
          valueFrom:
            fieldRef:
              fieldPath: metadata.labels['app']
EOF

kubectl apply -f /tmp/env-metadata.yaml
kubectl logs env-metadata | grep MY_
# Output:
# MY_APP_LABEL=demo
# MY_NODE_NAME=kind-worker
# MY_POD_IP=10.244.1.5
# MY_POD_NAME=env-metadata
# MY_POD_NAMESPACE=default

kubectl delete pod env-metadata
```

### Step 3: Environment from ConfigMap and Secret

```bash
# First, create a ConfigMap and Secret
kubectl create configmap app-config \
  --from-literal=DATABASE_HOST=postgres.default.svc \
  --from-literal=LOG_LEVEL=info

kubectl create secret generic app-secrets \
  --from-literal=DATABASE_PASSWORD=supersecret123

# Now create a pod that uses them
cat << 'EOF' > /tmp/env-configmap.yaml
apiVersion: v1
kind: Pod
metadata:
  name: env-configmap
spec:
  containers:
    - name: busybox
      image: busybox:1.36
      command: ["/bin/sh", "-c", "env | grep -E 'DATABASE|LOG' && sleep 3600"]
      env:
        # Single value from ConfigMap
        - name: DATABASE_HOST
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: DATABASE_HOST

        # Single value from Secret
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: DATABASE_PASSWORD

        # All values from ConfigMap as env vars
      envFrom:
        - configMapRef:
            name: app-config
EOF

kubectl apply -f /tmp/env-configmap.yaml
kubectl logs env-configmap
# Output:
# DATABASE_HOST=postgres.default.svc
# DATABASE_PASSWORD=supersecret123
# LOG_LEVEL=info

# Clean up
kubectl delete pod env-configmap
kubectl delete configmap app-config
kubectl delete secret app-secrets
```

---

## Lab 5: Resource Requests and Limits

### What You'll Learn
- CPU and memory requests (guaranteed minimum)
- CPU and memory limits (maximum allowed)
- What happens when limits are exceeded

### Step 1: Set requests and limits

```bash
cat << 'EOF' > /tmp/resources-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: resources-demo
spec:
  containers:
    - name: nginx
      image: nginx:1.25
      resources:
        # Minimum guaranteed resources
        requests:
          memory: "64Mi"      # 64 Mebibytes
          cpu: "100m"         # 100 millicores = 0.1 CPU

        # Maximum allowed resources
        limits:
          memory: "128Mi"     # Container killed (OOMKilled) if exceeded
          cpu: "200m"         # Container throttled if exceeded
EOF

kubectl apply -f /tmp/resources-demo.yaml

# View the resources
kubectl describe pod resources-demo | grep -A6 "Limits\|Requests"

kubectl delete pod resources-demo
```

### Step 2: Understanding resource units

| Unit | Meaning | Example |
|------|---------|---------|
| `m` | Millicores (1/1000 CPU) | `500m` = 0.5 CPU |
| `Mi` | Mebibytes (1024^2 bytes) | `128Mi` = 134MB |
| `Gi` | Gibibytes (1024^3 bytes) | `1Gi` = 1.07GB |
| No suffix | Bytes | `1000000` = 1MB |

### Step 3: See what happens when memory is exceeded

```bash
cat << 'EOF' > /tmp/oom-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: oom-demo
spec:
  containers:
    - name: memory-hog
      image: busybox:1.36
      resources:
        limits:
          memory: "50Mi"
      command:
        - /bin/sh
        - -c
        - |
          echo "Allocating memory..."
          # Try to allocate more than limit
          dd if=/dev/zero of=/tmp/bigfile bs=1M count=100 2>/dev/null
          echo "Done"
          sleep 3600
EOF

kubectl apply -f /tmp/oom-demo.yaml

# Watch the pod - it will be OOMKilled
kubectl get pods oom-demo -w

# After a moment, check status
kubectl describe pod oom-demo | grep -A3 "State\|Last State"
# You'll see: OOMKilled

kubectl delete pod oom-demo
```

---

## Lab 6: Volumes and Volume Mounts

### What You'll Learn
- emptyDir (temporary storage)
- Sharing volumes between containers
- hostPath (node storage - use carefully!)

### Step 1: emptyDir - temporary pod storage

```bash
cat << 'EOF' > /tmp/emptydir-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: emptydir-demo
spec:
  containers:
    - name: writer
      image: busybox:1.36
      command: ["/bin/sh", "-c"]
      args:
        - |
          for i in 1 2 3 4 5; do
            echo "Message $i at $(date)" >> /data/messages.txt
            sleep 2
          done
          sleep 3600
      volumeMounts:
        - name: shared-data
          mountPath: /data

    - name: reader
      image: busybox:1.36
      command: ["/bin/sh", "-c"]
      args:
        - |
          sleep 5
          echo "=== Reading messages ==="
          cat /data/messages.txt
          sleep 3600
      volumeMounts:
        - name: shared-data
          mountPath: /data

  volumes:
    - name: shared-data
      emptyDir: {}           # Created when pod starts, deleted when pod dies
EOF

kubectl apply -f /tmp/emptydir-demo.yaml

# Wait a few seconds, then check the reader's logs
sleep 8
kubectl logs emptydir-demo -c reader
# Output shows messages written by the writer container!

kubectl delete pod emptydir-demo
```

### Step 2: emptyDir in memory (tmpfs)

```bash
cat << 'EOF' > /tmp/memory-volume.yaml
apiVersion: v1
kind: Pod
metadata:
  name: memory-volume
spec:
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "df -h /cache && sleep 3600"]
      volumeMounts:
        - name: cache
          mountPath: /cache

  volumes:
    - name: cache
      emptyDir:
        medium: Memory       # Use RAM instead of disk
        sizeLimit: 100Mi     # Limit size
EOF

kubectl apply -f /tmp/memory-volume.yaml
kubectl logs memory-volume
# Shows tmpfs filesystem

kubectl delete pod memory-volume
```

### Step 3: Mounting ConfigMap as files

```bash
# Create a ConfigMap with file content
kubectl create configmap nginx-config \
  --from-literal=nginx.conf='server { listen 80; location / { return 200 "Hello from ConfigMap!"; } }'

cat << 'EOF' > /tmp/configmap-volume.yaml
apiVersion: v1
kind: Pod
metadata:
  name: configmap-volume
spec:
  containers:
    - name: nginx
      image: nginx:1.25
      volumeMounts:
        - name: config
          mountPath: /etc/nginx/conf.d
          readOnly: true

  volumes:
    - name: config
      configMap:
        name: nginx-config
        items:
          - key: nginx.conf
            path: default.conf     # Filename in the mount
EOF

kubectl apply -f /tmp/configmap-volume.yaml

# Test it
kubectl port-forward pod/configmap-volume 8080:80 &
sleep 2
curl http://localhost:8080
# Output: Hello from ConfigMap!
kill %1

kubectl delete pod configmap-volume
kubectl delete configmap nginx-config
```

---

## Lab 7: Restart Policy

### What You'll Learn
- Always (default) - for long-running services
- OnFailure - for jobs
- Never - for one-shot tasks

### Step 1: Compare restart policies

```bash
# Always (default) - restarts even on success
cat << 'EOF' > /tmp/restart-always.yaml
apiVersion: v1
kind: Pod
metadata:
  name: restart-always
spec:
  restartPolicy: Always
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Running...' && exit 0"]
EOF

# OnFailure - only restarts on non-zero exit
cat << 'EOF' > /tmp/restart-onfailure.yaml
apiVersion: v1
kind: Pod
metadata:
  name: restart-onfailure
spec:
  restartPolicy: OnFailure
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Running...' && exit 0"]
EOF

# Never - never restarts
cat << 'EOF' > /tmp/restart-never.yaml
apiVersion: v1
kind: Pod
metadata:
  name: restart-never
spec:
  restartPolicy: Never
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Running...' && exit 0"]
EOF

kubectl apply -f /tmp/restart-always.yaml
kubectl apply -f /tmp/restart-onfailure.yaml
kubectl apply -f /tmp/restart-never.yaml

# Watch them
kubectl get pods -w

# After a minute:
# restart-always:     Running (keeps restarting, RESTARTS column increases)
# restart-onfailure:  Completed (exit 0 = success, no restart)
# restart-never:      Completed (never restarts)

kubectl delete pod restart-always restart-onfailure restart-never
```

---

## Lab 8: Generate YAML - Don't Write From Scratch!

### What You'll Learn
- Generate YAML templates with kubectl
- Use `kubectl explain` to understand fields

### Step 1: Generate pod YAML

```bash
# Generate YAML without creating the pod
kubectl run nginx-generated --image=nginx:1.25 \
  --dry-run=client -o yaml

# Save to file
kubectl run nginx-generated --image=nginx:1.25 \
  --dry-run=client -o yaml > /tmp/generated.yaml

cat /tmp/generated.yaml
```

### Step 2: Generate with more options

```bash
# With port and labels
kubectl run nginx --image=nginx:1.25 \
  --port=80 \
  --labels="app=web,tier=frontend" \
  --dry-run=client -o yaml

# With environment variables
kubectl run nginx --image=nginx:1.25 \
  --env="LOG_LEVEL=debug" \
  --env="PORT=8080" \
  --dry-run=client -o yaml
```

### Step 3: Use kubectl explain

```bash
# Explain pod spec
kubectl explain pod.spec

# Explain containers
kubectl explain pod.spec.containers

# Explain specific field
kubectl explain pod.spec.containers.resources
kubectl explain pod.spec.containers.env

# Full recursive explanation
kubectl explain pod.spec --recursive | head -100
```

### Step 4: Get YAML from existing resources

```bash
# Create a pod
kubectl run existing-pod --image=nginx:1.25

# Get its full YAML (including status)
kubectl get pod existing-pod -o yaml

# Get just the spec (cleaner)
kubectl get pod existing-pod -o yaml | grep -A100 "spec:" | head -50

kubectl delete pod existing-pod
```

---

## Quick Reference: Pod YAML Template

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod                    # Required
  namespace: default              # Optional (defaults to current)
  labels:                         # Optional but recommended
    app: my-app
  annotations:                    # Optional
    description: "My pod"

spec:
  restartPolicy: Always           # Always, OnFailure, Never

  containers:
    - name: main                  # Required
      image: nginx:1.25           # Required

      ports:
        - containerPort: 80       # Documentation only

      env:
        - name: MY_VAR
          value: "hello"

      resources:
        requests:
          memory: "64Mi"
          cpu: "100m"
        limits:
          memory: "128Mi"
          cpu: "200m"

      volumeMounts:
        - name: data
          mountPath: /data

  volumes:
    - name: data
      emptyDir: {}
```

---

## Key Takeaways

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      WHAT YOU LEARNED                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Lab 1: Minimal pod needs only 4 fields                                 │
│  Lab 2: Labels are for selection, annotations for metadata              │
│  Lab 3: containerPort is documentation, not exposure                    │
│  Lab 4: Env vars can come from values, metadata, ConfigMaps, Secrets    │
│  Lab 5: Requests = guaranteed, Limits = maximum (OOMKilled if exceeded) │
│  Lab 6: emptyDir for temp storage, ConfigMap for config files           │
│  Lab 7: restartPolicy controls what happens when container exits        │
│  Lab 8: Use --dry-run and kubectl explain, don't write from scratch!    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Next Up

[1.3 kubectl Essentials](1.3_kubectl_essentials.md) — Master the commands you'll use daily

---

*Chapter 1.2 of Kubernetes 101: From Zero to Production*
