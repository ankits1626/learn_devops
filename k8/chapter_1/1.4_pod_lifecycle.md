# 1.4 Pod Lifecycle

> Understand pod states and transitions through hands-on labs

---

## Pod Lifecycle Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         POD LIFECYCLE                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   ┌─────────┐    ┌──────────────────┐    ┌─────────┐                    │
│   │ Pending │───▶│ContainerCreating │───▶│ Running │                    │
│   └─────────┘    └──────────────────┘    └────┬────┘                    │
│        │                                      │                         │
│        │              ┌───────────────────────┼───────────────────┐     │
│        │              │                       │                   │     │
│        │              ▼                       ▼                   ▼     │
│        │         ┌─────────┐           ┌───────────┐       ┌────────┐   │
│        │         │Succeeded│           │  Failed   │       │Unknown │   │
│        │         │ (exit 0)│           │(exit != 0)│       │(no node│   │
│        │         └─────────┘           └───────────┘       │contact)│   │
│        │                                                   └────────┘   │
│        ▼                                                                │
│   ┌──────────────┐                                                      │
│   │ Unschedulable│  (no node can run it)                                │
│   └──────────────┘                                                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Pod Phases Explained

| Phase | When It Occurs | What's Happening |
|-------|----------------|------------------|
| **Pending** | Pod accepted but not yet running | Waiting for scheduling, image pull, or init containers |
| **ContainerCreating** | Sub-state of Pending | Images being pulled, volumes mounted, sandbox created |
| **Running** | At least one container running | Main containers are executing |
| **Succeeded** | All containers exited with code 0 | Job/batch workload completed successfully |
| **Failed** | All containers terminated, at least one failed | Container crashed or exited with non-zero code |
| **Unknown** | Cannot determine pod state | Node communication lost, kubelet not responding |
| **Unschedulable** | Scheduler cannot place pod | No node has enough resources, taints block all nodes |

### Phase Transitions

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    PHASE TRANSITION TRIGGERS                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Pending → Running                                                      │
│  ─────────────────                                                      │
│  • Node assigned (PodScheduled = True)                                  │
│  • Images pulled successfully                                           │
│  • Init containers completed (Initialized = True)                       │
│  • At least one container started                                       │
│                                                                         │
│  Running → Succeeded                                                    │
│  ────────────────────                                                   │
│  • All containers exit with code 0                                      │
│  • restartPolicy: Never or OnFailure (won't restart)                    │
│  • Typical for Jobs and batch workloads                                 │
│                                                                         │
│  Running → Failed                                                       │
│  ─────────────────                                                      │
│  • Container exits with non-zero code                                   │
│  • restartPolicy: Never (won't restart)                                 │
│  • Or: exceeded restart limit with OnFailure                            │
│                                                                         │
│  Any → Unknown                                                          │
│  ────────────                                                           │
│  • Node stops responding to API server                                  │
│  • Network partition between node and control plane                     │
│  • Kubelet crashes or stops reporting                                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Common Pending Sub-States

When a pod is `Pending`, check the **reason** field:

| Reason | Cause | Solution |
|--------|-------|----------|
| `Unschedulable` | No node can run the pod | Check resources, taints, node selectors |
| `ImagePullBackOff` | Cannot pull container image | Verify image name, registry credentials |
| `ErrImagePull` | Initial image pull failure | Check network, image exists |
| `ContainerCreating` | Setting up pod sandbox | Wait, or check CNI/volume issues |
| `PodInitializing` | Init containers running | Wait for init containers to complete |

---

## Lab 1: Observe Pod Phases

### What You'll Learn

- The 5 pod phases: Pending, Running, Succeeded, Failed, Unknown
- How to observe phase transitions

### Step 1: Watch a pod go through phases

```bash
# Terminal 1: Watch pods
kubectl get pods -w

# Terminal 2: Create a pod
kubectl run phase-demo --image=nginx:1.25

# In Terminal 1, you'll see:
# NAME         READY   STATUS              RESTARTS   AGE
# phase-demo   0/1     Pending             0          0s
# phase-demo   0/1     ContainerCreating   0          0s
# phase-demo   1/1     Running             0          2s
```

### Step 2: See each phase

```bash
# Check current phase
kubectl get pod phase-demo -o jsonpath='{.status.phase}'
# Output: Running

# Full status
kubectl get pod phase-demo -o yaml | grep -A20 "status:"
```

### Step 3: Create a Succeeded pod

```bash
# Pod that completes successfully
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: succeeded-demo
spec:
  restartPolicy: Never
  containers:
    - name: task
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Done!' && exit 0"]
EOF

# Watch it
kubectl get pods -w

# After a few seconds:
# succeeded-demo   0/1     Completed   0          5s

# Check phase
kubectl get pod succeeded-demo -o jsonpath='{.status.phase}'
# Output: Succeeded
```

### Step 4: Create a Failed pod

```bash
# Pod that fails
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: failed-demo
spec:
  restartPolicy: Never
  containers:
    - name: task
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Failing!' && exit 1"]
EOF

# Watch it
kubectl get pods -w

# After a few seconds:
# failed-demo   0/1     Error   0          3s

# Check phase
kubectl get pod failed-demo -o jsonpath='{.status.phase}'
# Output: Failed
```

### Cleanup

```bash
kubectl delete pod phase-demo succeeded-demo failed-demo
```

---

## Lab 2: Container States

### What You'll Learn

- Container states: Waiting, Running, Terminated
- How to read container status

### The Three Container States

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      CONTAINER STATES                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   WAITING                                                               │
│   • Container not yet running                                           │
│   • Reasons: ContainerCreating, ImagePullBackOff, CrashLoopBackOff      │
│                                                                         │
│   RUNNING                                                               │
│   • Container is executing                                              │
│   • Has startedAt timestamp                                             │
│                                                                         │
│   TERMINATED                                                            │
│   • Container finished execution                                        │
│   • Has exitCode, startedAt, finishedAt                                 │
│   • Reasons: Completed (exit 0), Error (exit != 0), OOMKilled           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Step 1: Observe Waiting state

```bash
# Create pod with non-existent image
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: waiting-demo
spec:
  containers:
    - name: app
      image: this-image-does-not-exist:v999
EOF

# Watch it
kubectl get pods -w

# You'll see:
# waiting-demo   0/1     ErrImagePull        0          5s
# waiting-demo   0/1     ImagePullBackOff    0          10s

# Check container state
kubectl get pod waiting-demo -o jsonpath='{.status.containerStatuses[0].state}' | jq .

# Output:
# {
#   "waiting": {
#     "message": "...",
#     "reason": "ImagePullBackOff"
#   }
# }

kubectl delete pod waiting-demo
```

### Step 2: Observe Running state

```bash
kubectl run running-demo --image=nginx:1.25
kubectl wait --for=condition=Ready pod/running-demo --timeout=60s

# Check container state
kubectl get pod running-demo -o jsonpath='{.status.containerStatuses[0].state}' | jq .

# Output:
# {
#   "running": {
#     "startedAt": "2024-01-26T10:00:00Z"
#   }
# }

kubectl delete pod running-demo
```

### Step 3: Observe Terminated state

```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: terminated-demo
spec:
  restartPolicy: Never
  containers:
    - name: task
      image: busybox:1.36
      command: ["/bin/sh", "-c", "sleep 2 && exit 0"]
EOF

# Wait for completion
sleep 5

# Check container state
kubectl get pod terminated-demo -o jsonpath='{.status.containerStatuses[0].state}' | jq .

# Output:
# {
#   "terminated": {
#     "containerID": "...",
#     "exitCode": 0,
#     "finishedAt": "2024-01-26T10:00:05Z",
#     "reason": "Completed",
#     "startedAt": "2024-01-26T10:00:03Z"
#   }
# }

kubectl delete pod terminated-demo
```

---

## Lab 3: Restart Policies in Action

### What You'll Learn

- How restartPolicy affects pod behavior
- The difference between Always, OnFailure, Never

### Step 1: restartPolicy: Always (default)

```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: restart-always
spec:
  restartPolicy: Always
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Running' && sleep 3 && exit 0"]
EOF

# Watch it - keeps restarting even on success!
kubectl get pods restart-always -w

# After ~30 seconds, RESTARTS column increases
# NAME             READY   STATUS    RESTARTS     AGE
# restart-always   1/1     Running   3 (2s ago)   30s

kubectl delete pod restart-always
```

### Step 2: restartPolicy: OnFailure

```bash
# Success case - doesn't restart
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: onfailure-success
spec:
  restartPolicy: OnFailure
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Success' && exit 0"]
EOF

# Failure case - restarts
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: onfailure-fail
spec:
  restartPolicy: OnFailure
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Failing' && exit 1"]
EOF

kubectl get pods -w

# onfailure-success: Completed (no restarts)
# onfailure-fail: keeps restarting, eventually CrashLoopBackOff

kubectl delete pod onfailure-success onfailure-fail
```

### Step 3: restartPolicy: Never

```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: restart-never-fail
spec:
  restartPolicy: Never
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Failing' && exit 1"]
EOF

kubectl get pods -w

# Never restarts - stays in Error state
# NAME                 READY   STATUS   RESTARTS   AGE
# restart-never-fail   0/1     Error    0          5s

kubectl delete pod restart-never-fail
```

---

## Lab 4: CrashLoopBackOff

### What You'll Learn

- What causes CrashLoopBackOff
- The exponential backoff timer
- How to debug it

### Step 1: Create a crashing pod

```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: crashloop-demo
spec:
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Starting...' && exit 1"]
EOF

# Watch the progression
kubectl get pods crashloop-demo -w
```

### Step 2: Understand the backoff

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    CRASHLOOPBACKOFF TIMELINE                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   Crash #1 → Wait 10s  → Restart                                        │
│   Crash #2 → Wait 20s  → Restart                                        │
│   Crash #3 → Wait 40s  → Restart                                        │
│   Crash #4 → Wait 80s  → Restart                                        │
│   Crash #5 → Wait 160s → Restart                                        │
│   Crash #6 → Wait 300s → Restart (capped at 5 minutes)                  │
│   ...                                                                   │
│                                                                         │
│   Status shows: CrashLoopBackOff (waiting for next restart)             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Step 3: Debug CrashLoopBackOff

```bash
# Check logs (even from crashed containers)
kubectl logs crashloop-demo
kubectl logs crashloop-demo --previous

# Check events
kubectl describe pod crashloop-demo | grep -A10 Events

# Check exit code
kubectl get pod crashloop-demo -o jsonpath='{.status.containerStatuses[0].lastState.terminated.exitCode}'
```

### Common causes and solutions

| Cause | How to Identify | Solution |
|-------|-----------------|----------|
| App crashes | Check logs | Fix application bug |
| Missing config | Logs show config error | Add ConfigMap/Secret |
| Bad command | Exit immediately | Fix command/args |
| OOMKilled | exitCode=137 | Increase memory limit |
| Permission denied | Logs show permission error | Fix securityContext |

### Cleanup

```bash
kubectl delete pod crashloop-demo
```

---

## Lab 5: Init Containers Lifecycle

### What You'll Learn

- Init containers run before main containers
- Pod stays in Init:X/Y until all init containers complete
- If init container fails, pod doesn't start

### Step 1: Successful init containers

```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: init-demo
spec:
  initContainers:
    - name: init-1
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Init 1 running' && sleep 3 && echo 'Init 1 done'"]

    - name: init-2
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Init 2 running' && sleep 3 && echo 'Init 2 done'"]

  containers:
    - name: app
      image: nginx:1.25
EOF

# Watch the progression
kubectl get pods init-demo -w

# You'll see:
# NAME        READY   STATUS     RESTARTS   AGE
# init-demo   0/1     Init:0/2   0          0s
# init-demo   0/1     Init:1/2   0          4s
# init-demo   0/1     Init:2/2   0          8s   (briefly)
# init-demo   0/1     PodInitializing   0   8s
# init-demo   1/1     Running    0          10s
```

### Step 2: Check init container logs

```bash
# Logs from init containers
kubectl logs init-demo -c init-1
kubectl logs init-demo -c init-2

# Logs from main container
kubectl logs init-demo
```

### Step 3: Failing init container

```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: init-fail-demo
spec:
  initContainers:
    - name: init-ok
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'OK' && exit 0"]

    - name: init-fail
      image: busybox:1.36
      command: ["/bin/sh", "-c", "echo 'Failing' && exit 1"]

  containers:
    - name: app
      image: nginx:1.25
EOF

# Watch it - stuck at Init:1/2
kubectl get pods init-fail-demo -w

# NAME             READY   STATUS       RESTARTS   AGE
# init-fail-demo   0/1     Init:1/2     0          5s
# init-fail-demo   0/1     Init:Error   0          6s
# init-fail-demo   0/1     Init:1/2     1          7s  (restarting init-fail)

# Main container never starts!
```

### Cleanup

```bash
kubectl delete pod init-demo init-fail-demo
```

---

## Lab 6: Pod Conditions

### What You'll Learn

- Pod conditions: PodScheduled, Initialized, ContainersReady, Ready
- How to check conditions
- Using conditions for debugging

### Step 1: View pod conditions

```bash
kubectl run conditions-demo --image=nginx:1.25
kubectl wait --for=condition=Ready pod/conditions-demo --timeout=60s

# Get all conditions
kubectl get pod conditions-demo -o jsonpath='{.status.conditions}' | jq .
```

### The Four Pod Conditions

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      POD CONDITIONS                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   PodScheduled                                                          │
│   • Pod has been assigned to a node                                     │
│   • False if: insufficient resources, taints, affinity rules            │
│                                                                         │
│   Initialized                                                           │
│   • All init containers have completed successfully                     │
│   • False if: init container still running or failed                    │
│                                                                         │
│   ContainersReady                                                       │
│   • All containers are ready                                            │
│   • False if: container starting, failing, or probe failing             │
│                                                                         │
│   Ready                                                                 │
│   • Pod is ready to serve traffic                                       │
│   • This is what Services check to include pod in endpoints             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Step 2: Check individual conditions

```bash
# Check if Ready
kubectl get pod conditions-demo -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}'
# Output: True

# Check all condition types and their status
kubectl get pod conditions-demo -o jsonpath='{range .status.conditions[*]}{.type}: {.status}{"\n"}{end}'
# Output:
# PodScheduled: True
# Initialized: True
# ContainersReady: True
# Ready: True
```

### Step 3: See condition transitions

```bash
# Create pod that takes time to initialize
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: slow-init
spec:
  initContainers:
    - name: slow-init
      image: busybox:1.36
      command: ["/bin/sh", "-c", "sleep 10"]
  containers:
    - name: app
      image: nginx:1.25
EOF

# Quickly check conditions (before init completes)
kubectl get pod slow-init -o jsonpath='{range .status.conditions[*]}{.type}: {.status}{"\n"}{end}'
# Initialized: False

# After init completes
sleep 12
kubectl get pod slow-init -o jsonpath='{range .status.conditions[*]}{.type}: {.status}{"\n"}{end}'
# Initialized: True
```

### Cleanup

```bash
kubectl delete pod conditions-demo slow-init
```

---

## Lab 7: Termination and Graceful Shutdown

### What You'll Learn

- What happens when a pod is deleted
- Grace period and SIGTERM/SIGKILL
- terminationGracePeriodSeconds

### The Termination Process

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    POD TERMINATION TIMELINE                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   kubectl delete pod my-pod                                             │
│   │                                                                     │
│   ▼                                                                     │
│   1. Pod marked as "Terminating"                                        │
│   │  • Removed from Service endpoints                                   │
│   │  • preStop hook runs (if defined)                                   │
│   │                                                                     │
│   ▼                                                                     │
│   2. SIGTERM sent to containers                                         │
│   │  • App should catch this and shutdown gracefully                    │
│   │  • Close connections, save state, etc.                              │
│   │                                                                     │
│   ▼                                                                     │
│   3. Grace period countdown (default: 30 seconds)                       │
│   │                                                                     │
│   ▼                                                                     │
│   4. SIGKILL sent (if still running)                                    │
│   │  • Forceful termination                                             │
│   │                                                                     │
│   ▼                                                                     │
│   5. Pod removed from API server                                        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Step 1: Observe normal termination

```bash
# Create a pod that handles SIGTERM
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: graceful-demo
spec:
  terminationGracePeriodSeconds: 10
  containers:
    - name: app
      image: busybox:1.36
      command:
        - /bin/sh
        - -c
        - |
          trap 'echo "Received SIGTERM, shutting down..."; exit 0' TERM
          echo "App started with PID $$"
          while true; do sleep 1; done
EOF

kubectl wait --for=condition=Ready pod/graceful-demo --timeout=60s

# In another terminal, watch the pod
kubectl get pods -w

# Delete and observe
kubectl delete pod graceful-demo

# You'll see it go to Terminating, then disappear
```

### Step 2: Pod that doesn't handle SIGTERM

```bash
cat << 'EOF' | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: no-graceful
spec:
  terminationGracePeriodSeconds: 5
  containers:
    - name: app
      image: busybox:1.36
      command: ["/bin/sh", "-c", "while true; do sleep 1; done"]
EOF

kubectl wait --for=condition=Ready pod/no-graceful --timeout=60s

# Delete with timing
time kubectl delete pod no-graceful

# Takes ~5 seconds (grace period) then SIGKILL
```

### Step 3: Force delete (skip grace period)

```bash
kubectl run force-demo --image=nginx:1.25
kubectl wait --for=condition=Ready pod/force-demo --timeout=60s

# Force delete - immediate
time kubectl delete pod force-demo --force --grace-period=0

# Almost instant!
```

---

## Lab 8: Pod Events Timeline

### What You'll Learn

- How to read pod events
- Common events and what they mean
- Debugging with events

### Step 1: View events for a pod

```bash
kubectl run events-demo --image=nginx:1.25
kubectl wait --for=condition=Ready pod/events-demo --timeout=60s

# View events
kubectl describe pod events-demo | grep -A20 "Events:"

# Events:
#   Type    Reason     Age   From               Message
#   ----    ------     ----  ----               -------
#   Normal  Scheduled  10s   default-scheduler  Successfully assigned default/events-demo to kind-worker
#   Normal  Pulling    10s   kubelet            Pulling image "nginx:1.25"
#   Normal  Pulled     8s    kubelet            Successfully pulled image "nginx:1.25"
#   Normal  Created    8s    kubelet            Created container nginx
#   Normal  Started    8s    kubelet            Started container nginx
```

### Step 2: Common events reference

| Event | Type | Meaning |
|-------|------|---------|
| Scheduled | Normal | Pod assigned to node |
| Pulling | Normal | Pulling container image |
| Pulled | Normal | Image pulled successfully |
| Created | Normal | Container created |
| Started | Normal | Container started |
| Killing | Normal | Container being terminated |
| FailedScheduling | Warning | No node available |
| Failed | Warning | Container failed |
| BackOff | Warning | Restarting after backoff |
| Unhealthy | Warning | Probe failed |
| OOMKilled | Warning | Out of memory |

### Step 3: Watch cluster events

```bash
# All events in namespace
kubectl get events --sort-by=.lastTimestamp

# Watch events in real-time
kubectl get events -w

# Events for specific pod
kubectl get events --field-selector involvedObject.name=events-demo
```

### Cleanup

```bash
kubectl delete pod events-demo
```

---

## Quick Reference

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    POD LIFECYCLE SUMMARY                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  POD PHASES:                                                            │
│  • Pending      - Waiting for scheduling or image pull                  │
│  • Running      - At least one container running                        │
│  • Succeeded    - All containers exited with code 0                     │
│  • Failed       - At least one container failed                         │
│  • Unknown      - Node communication lost                               │
│                                                                         │
│  CONTAINER STATES:                                                      │
│  • Waiting      - Not yet running (pulling, etc.)                       │
│  • Running      - Executing                                             │
│  • Terminated   - Finished (exit code available)                        │
│                                                                         │
│  RESTART POLICIES:                                                      │
│  • Always       - Always restart (default)                              │
│  • OnFailure    - Restart only on failure                               │
│  • Never        - Never restart                                         │
│                                                                         │
│  DEBUGGING COMMANDS:                                                    │
│  • kubectl describe pod <name>     # Events and status                  │
│  • kubectl logs <pod>              # Current logs                       │
│  • kubectl logs <pod> --previous   # Previous container logs            │
│  • kubectl get events              # Cluster events                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Key Takeaways

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      WHAT YOU LEARNED                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Lab 1: Pod phases - Pending, Running, Succeeded, Failed, Unknown       │
│  Lab 2: Container states - Waiting, Running, Terminated                 │
│  Lab 3: Restart policies - Always, OnFailure, Never                     │
│  Lab 4: CrashLoopBackOff - exponential backoff, debugging               │
│  Lab 5: Init containers - run before main, must succeed                 │
│  Lab 6: Pod conditions - PodScheduled, Initialized, Ready               │
│  Lab 7: Termination - SIGTERM, grace period, SIGKILL                    │
│  Lab 8: Events - timeline of what happened                              │
│                                                                         │
│  Key debugging flow:                                                    │
│  1. kubectl get pods (see STATUS)                                       │
│  2. kubectl describe pod (see Events)                                   │
│  3. kubectl logs (see application output)                               │
│  4. kubectl logs --previous (if container restarted)                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Next Up

Chapter 1 complete! Continue to [Chapter 2: Deployments & ReplicaSets](../chapter_2/chapter_2_overview.md)

---

*Chapter 1.4 of Kubernetes 101: From Zero to Production*
