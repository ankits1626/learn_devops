# 0.2d Explore the Controller Manager

> The watch-and-fix loop - makes sure reality matches your desires

---

## What is the Controller Manager?

The Controller Manager (`kube-controller-manager`) runs multiple controllers that continuously watch the cluster state and make corrections.

```text
┌─────────────────────────────────────────────────────────────────┐
│                  CONTROLLER MANAGER                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Contains many controllers, each with a simple job:            │
│                                                                 │
│   ┌──────────────────────────────────────────────────────────┐  │
│   │  THE CONTROL LOOP                                        │  │
│   │                                                          │  │
│   │       ┌─────────┐                                        │  │
│   │       │ Observe │ ◀──────────────────────────┐           │  │
│   │       │ Current │                            │           │  │
│   │       │  State  │                            │           │  │
│   │       └────┬────┘                            │           │  │
│   │            │                                 │           │  │
│   │            ▼                                 │           │  │
│   │       ┌─────────┐     ┌─────────┐           │           │  │
│   │       │ Compare │────▶│   Act   │───────────┘           │  │
│   │       │   to    │     │ (fix    │                       │  │
│   │       │ Desired │     │  diff)  │                       │  │
│   │       └─────────┘     └─────────┘                       │  │
│   │                                                          │  │
│   │   This runs FOREVER, every few seconds                   │  │
│   └──────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Common Controllers

| Controller | Watches | Fixes |
|------------|---------|-------|
| **ReplicaSet Controller** | Deployments/ReplicaSets | Creates/deletes pods to match replica count |
| **Node Controller** | Nodes | Marks unreachable nodes, evicts pods |
| **Job Controller** | Jobs | Creates pods to run tasks to completion |
| **Endpoint Controller** | Services and Pods | Updates service endpoints when pods change |
| **ServiceAccount Controller** | Namespaces | Creates default ServiceAccount |

---

## Hands-On: Find the Controller Manager

```bash
# Find the controller manager pod
kubectl get pods -n kube-system | grep controller-manager

# Describe it
kubectl describe pod kube-controller-manager-playground-control-plane -n kube-system
```

Notice the many `--controllers` flags showing which controllers are enabled.

---

## Hands-On: Watch the ReplicaSet Controller

This is the most visible controller. Let's see it in action!

### Step 1: Create a Deployment

```bash
# Create a deployment with 3 replicas
kubectl create deployment nginx-demo --image=nginx:alpine --replicas=3

# Watch pods appear
kubectl get pods -w
```

What happened:
1. You created a Deployment
2. Deployment controller created a ReplicaSet
3. ReplicaSet controller created 3 Pods
4. Scheduler assigned nodes to each pod
5. Kubelets started the containers

### Step 2: Kill a Pod - Watch Self-Healing

```bash
# List the pods
kubectl get pods

# Delete one (use actual pod name)
kubectl delete pod <nginx-demo-xxx-yyy> --wait=false

# Immediately watch
kubectl get pods -w
```

You'll see:
```text
nginx-demo-xxx-yyy   1/1     Terminating   0          2m
nginx-demo-xxx-NEW   0/1     Pending       0          0s
nginx-demo-xxx-NEW   0/1     ContainerCreating   0   1s
nginx-demo-xxx-NEW   1/1     Running       0          3s
```

**The ReplicaSet controller noticed 2 pods instead of 3 and created a new one!**

### Step 3: Scale Up - Watch Controller React

```bash
# Scale to 5 replicas
kubectl scale deployment nginx-demo --replicas=5

# Watch new pods appear
kubectl get pods -w
```

### Step 4: Scale Down - Watch Controller React

```bash
# Scale to 1 replica
kubectl scale deployment nginx-demo --replicas=1

# Watch pods disappear
kubectl get pods -w
```

The controller terminates excess pods to match desired state.

```bash
# Cleanup
kubectl delete deployment nginx-demo
```

---

## Hands-On: See Controller Decisions in Events

```bash
# Create a deployment
kubectl create deployment event-demo --image=nginx:alpine --replicas=2

# See the events
kubectl get events --sort-by='.lastTimestamp'
```

Look for:
```text
ScalingReplicaSet   Scaled up replica set event-demo-xxx to 2
SuccessfulCreate    Created pod: event-demo-xxx-yyy
```

These events are created by the controllers!

```bash
kubectl delete deployment event-demo
```

---

## Hands-On: Watch Controller Manager Logs

```bash
# View controller manager logs
kubectl logs kube-controller-manager-playground-control-plane -n kube-system | tail -50

# Filter for specific controller
kubectl logs kube-controller-manager-playground-control-plane -n kube-system | grep -i "replica"
```

---

## Hands-On: Node Controller

The Node Controller monitors node health.

### Step 1: Check Node Status

```bash
# See node conditions
kubectl describe node playground-worker | grep -A10 Conditions
```

You'll see:
```text
Conditions:
  Type             Status
  Ready            True
  MemoryPressure   False
  DiskPressure     False
  PIDPressure      False
```

### Step 2: Simulate Node Issues (Careful!)

The Node Controller watches for nodes that stop responding. In production, if a node goes silent for 5 minutes, pods get evicted.

```bash
# Let's see the Node Controller's settings
kubectl describe pod kube-controller-manager-playground-control-plane -n kube-system | grep node
```

Look for flags like:
- `--node-monitor-period` - How often to check nodes
- `--node-monitor-grace-period` - How long before marking NotReady
- `--pod-eviction-timeout` - How long before evicting pods from bad nodes

---

## Hands-On: Job Controller

The Job Controller ensures tasks run to completion.

```bash
# Create a job that runs a command
cat <<EOF | kubectl apply -f -
apiVersion: batch/v1
kind: Job
metadata:
  name: job-demo
spec:
  template:
    spec:
      containers:
      - name: counter
        image: busybox
        command: ["sh", "-c", "echo 'Job running!'; sleep 5; echo 'Done!'"]
      restartPolicy: Never
EOF

# Watch the job
kubectl get jobs -w

# See the pod it created
kubectl get pods

# Check the output
kubectl logs job-demo-xxxxx
```

The Job Controller:
1. Saw a Job object
2. Created a Pod to run the job
3. Watched the Pod complete
4. Marked the Job as complete

```bash
# Cleanup
kubectl delete job job-demo
```

---

## Hands-On: Endpoint Controller

The Endpoint Controller maintains the list of pod IPs behind a Service.

### Step 1: Create a Deployment and Service

```bash
# Create deployment
kubectl create deployment web --image=nginx:alpine --replicas=3

# Expose as a service
kubectl expose deployment web --port=80

# See the endpoints
kubectl get endpoints web
```

Output:
```text
NAME   ENDPOINTS                                   AGE
web    10.244.1.5:80,10.244.1.6:80,10.244.2.3:80   10s
```

### Step 2: Scale and Watch Endpoints Change

```bash
# Watch endpoints
kubectl get endpoints web -w
```

In another terminal:
```bash
# Scale up
kubectl scale deployment web --replicas=5
```

Watch the endpoints list grow!

```bash
# Scale down
kubectl scale deployment web --replicas=1
```

Watch the endpoints shrink!

The Endpoint Controller automatically updates the endpoint list when pods change.

```bash
# Cleanup
kubectl delete deployment web
kubectl delete service web
```

---

## Experiment: What Happens Without Controllers?

Controllers are what make Kubernetes "self-healing". Without them:

```text
┌─────────────────────────────────────────────────────────────────┐
│               WITHOUT CONTROLLERS                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   You: "Run 3 replicas"                                         │
│   K8s: Creates 3 pods                                           │
│                                                                 │
│   Pod dies...                                                   │
│                                                                 │
│   K8s: Does nothing! You said 3, now you have 2. Too bad.       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                WITH CONTROLLERS                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   You: "Run 3 replicas"                                         │
│   Controller: Watches... sees 0 pods. Creates 3.                │
│                                                                 │
│   Pod dies...                                                   │
│                                                                 │
│   Controller: Watches... sees 2 pods. Creates 1 more.           │
│                                                                 │
│   Back to 3! Self-healing!                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Hands-On: Desired vs Current State

Let's visualize the controller's job:

```bash
# Create deployment
kubectl create deployment state-demo --image=nginx:alpine --replicas=3

# Check desired vs current
kubectl get deployment state-demo
```

Output:
```text
NAME         READY   UP-TO-DATE   AVAILABLE   AGE
state-demo   3/3     3            3           30s
```

- `3/3` = Current/Desired
- Controller's job: Keep these equal

```bash
# Mess with current state
kubectl delete pod -l app=state-demo --all --wait=false

# Immediately check
kubectl get deployment state-demo
```

Briefly you might see `0/3`, then it recovers to `3/3`!

```bash
kubectl delete deployment state-demo
```

---

## Advanced: Custom Controllers

Kubernetes is extensible - you can write your own controllers!

```text
Custom Resource (CR)          + Custom Controller
       │                              │
       ▼                              ▼
"I want 5 Redis clusters"    Watches for Redis CRs
                             Creates StatefulSets
                             Configures networking
                             Manages backups
```

This is how tools like Prometheus Operator, Cert-Manager, and ArgoCD work.

---

## Key Takeaways

1. **Controllers are reconciliation loops** - Watch, compare, fix
2. **Each controller has one job** - ReplicaSet controller manages replicas, Node controller manages nodes
3. **This is how self-healing works** - Controllers fix drift automatically
4. **Declarative model** - You say what you want, controllers make it happen
5. **Runs continuously** - Every few seconds, checking and fixing
6. **Events show controller actions** - `kubectl get events` reveals what happened

---

## Quick Reference

```bash
# Find controller manager
kubectl get pods -n kube-system | grep controller-manager

# View logs
kubectl logs kube-controller-manager-playground-control-plane -n kube-system

# See events (controller actions)
kubectl get events --sort-by='.lastTimestamp'

# Watch deployment status (shows controller work)
kubectl get deployment <name> -w

# Check endpoints (endpoint controller)
kubectl get endpoints <service-name>

# See replica counts
kubectl get deployment <name> -o wide
```

---

**Next:** [0.2e Explore kubelet](./0.2e_explore_kubelet.md)
