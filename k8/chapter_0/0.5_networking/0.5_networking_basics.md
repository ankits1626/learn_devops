# 0.5 Networking Basics

> Understanding how containers and pods talk to each other

---

## Why Networking Matters in Kubernetes

In Kubernetes, your application is split into many pods that need to communicate:
- Frontend pod talks to backend pod
- Backend pod talks to database pod
- External users access your frontend

Understanding networking is essential for troubleshooting "why can't my pod connect?"

---

## Part 1: Networking Fundamentals

Before diving into Kubernetes networking, let's understand the basics.

### What is a Port?

A **port** is a number (0-65535) that identifies a specific service on a machine. Think of it like apartment numbers in a building.

```text
┌─────────────────────────────────────────────────────────────────┐
│                    YOUR COMPUTER = BUILDING                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   IP Address: 192.168.1.100 (building address)                  │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  Apartment 22   → SSH server lives here                 │   │
│   │  Apartment 80   → Web server (HTTP) lives here          │   │
│   │  Apartment 443  → Secure web (HTTPS) lives here         │   │
│   │  Apartment 3000 → Your Node.js app lives here           │   │
│   │  Apartment 5432 → PostgreSQL lives here                 │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   To visit SSH: go to 192.168.1.100, apartment 22               │
│   Written as: 192.168.1.100:22                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Common Ports to Know

| Port | Service | What It Does |
|------|---------|--------------|
| 22 | SSH | Remote terminal access |
| 80 | HTTP | Web traffic (unencrypted) |
| 443 | HTTPS | Web traffic (encrypted) |
| 3000 | Node.js (common) | Development servers |
| 3306 | MySQL | Database |
| 5432 | PostgreSQL | Database |
| 6379 | Redis | Cache/message broker |
| 8080 | HTTP alternate | Common for proxies, APIs |
| 27017 | MongoDB | Database |

### Hands-On: See What's Listening on Ports

```bash
# On your Mac, see which ports are in use
lsof -i -P | grep LISTEN

# Or check a specific port
lsof -i :8080
```

---

### What is an IP Address?

An **IP address** uniquely identifies a device on a network.

```text
┌─────────────────────────────────────────────────────────────────┐
│                      IP ADDRESSES                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   IPv4 Format: 192.168.1.100                                    │
│                ─── ─── ─ ───                                    │
│                 │   │  │  │                                     │
│                 └───┴──┴──┴── Four numbers, each 0-255          │
│                                                                 │
│   Special IP Addresses:                                         │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  127.0.0.1     → localhost (this machine, "myself")     │   │
│   │  0.0.0.0       → "all interfaces" (listen everywhere)   │   │
│   │  10.x.x.x      → Private network (K8s pods use this)    │   │
│   │  192.168.x.x   → Private network (home routers)         │   │
│   │  172.16-31.x.x → Private network (Docker default)       │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   Private IPs: Only work within a network (not internet)        │
│   Public IPs: Reachable from the internet                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### localhost vs 0.0.0.0 (Important for Containers!)

```text
┌─────────────────────────────────────────────────────────────────┐
│              localhost (127.0.0.1) vs 0.0.0.0                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   localhost / 127.0.0.1:                                        │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  "Only I can talk to myself"                            │   │
│   │                                                         │   │
│   │   App listening on localhost:3000                       │   │
│   │        ↑                                                │   │
│   │   Only accessible from SAME machine                     │   │
│   │   External requests? BLOCKED!                           │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   0.0.0.0:                                                      │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  "Anyone can talk to me"                                │   │
│   │                                                         │   │
│   │   App listening on 0.0.0.0:3000                         │   │
│   │        ↑                                                │   │
│   │   Accessible from ANY network interface                 │   │
│   │   External requests? ALLOWED!                           │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   CONTAINER GOTCHA:                                             │
│   Apps inside containers MUST bind to 0.0.0.0, not localhost,   │
│   to be reachable from outside the container!                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### What is DNS?

**DNS** (Domain Name System) translates human-readable names to IP addresses.

```text
┌─────────────────────────────────────────────────────────────────┐
│                         DNS                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   You type: google.com                                          │
│                                                                 │
│   DNS Server: "Let me look that up..."                          │
│               "google.com = 142.250.80.46"                      │
│                                                                 │
│   Your browser: Connects to 142.250.80.46                       │
│                                                                 │
│   ─────────────────────────────────────────────────────────     │
│                                                                 │
│   In Kubernetes, EVERY Service gets a DNS name automatically!   │
│                                                                 │
│   my-service              → 10.96.45.23  (short form)           │
│   my-service.default      → 10.96.45.23  (with namespace)       │
│   my-service.default.svc  → 10.96.45.23  (full form)            │
│   my-service.default.svc.cluster.local → 10.96.45.23 (FQDN)     │
│                                                                 │
│   Pods can use these names instead of remembering IPs!          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Hands-On: DNS Resolution

```bash
# See DNS resolution on your Mac
nslookup google.com

# Inside a K8s pod, you can resolve service names
kubectl run dns-test --image=busybox --rm -it --restart=Never -- nslookup kubernetes
```

---

## Part 2: Container Networking

### Port Mapping (Container to Host)

When you run a container, its ports are isolated. To access them, you **map** container ports to host ports.

```bash
podman run -p 8080:80 nginx
#          ─────────
#           │    │
#           │    └── Container port (nginx listens on 80)
#           └─────── Host port (you access via localhost:8080)
```

```text
┌─────────────────────────────────────────────────────────────────┐
│                    PORT MAPPING                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Your Mac                          Container                   │
│   ┌─────────────────────┐          ┌─────────────────────┐      │
│   │                     │          │                     │      │
│   │  localhost:8080 ────┼─────────▶│ nginx on port 80    │      │
│   │                     │          │                     │      │
│   │                     │          │ (isolated network)  │      │
│   └─────────────────────┘          └─────────────────────┘      │
│                                                                 │
│   Without -p 8080:80, you CANNOT reach the container!           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Hands-On: Port Mapping

```bash
# Run nginx, map port 8080 on host to port 80 in container
podman run -d --name web -p 8080:80 nginx:alpine

# Access it
curl localhost:8080

# See the port mapping
podman port web

# Cleanup
podman rm -f web
```

### Container Bridge Network

Containers on the same host can talk to each other through a **bridge network**.

```text
┌─────────────────────────────────────────────────────────────────┐
│                    HOST MACHINE                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│   │ Container A │    │ Container B │    │ Container C │         │
│   │ 172.17.0.2  │    │ 172.17.0.3  │    │ 172.17.0.4  │         │
│   └──────┬──────┘    └──────┬──────┘    └──────┬──────┘         │
│          │                  │                  │                │
│          └──────────────────┼──────────────────┘                │
│                             │                                   │
│                    ┌────────┴────────┐                          │
│                    │  Bridge Network │                          │
│                    │   172.17.0.1    │                          │
│                    └────────┬────────┘                          │
│                             │                                   │
│                        Host Network                             │
│                                                                 │
│   Containers can reach each other via their 172.17.x.x IPs      │
│   Or by container name if on the same user-defined network      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Hands-On: Container-to-Container Communication

```bash
# Create a network
podman network create mynet

# Run two containers on the same network
podman run -d --name web --network mynet nginx:alpine
podman run -d --name client --network mynet busybox sleep 3600

# From client, reach web by NAME
podman exec client wget -qO- http://web:80

# Cleanup
podman rm -f web client
podman network rm mynet
```

---

## Part 3: Kubernetes Networking Model

Kubernetes networking follows these rules:

1. **Every Pod gets its own IP address** - No manual port mapping needed
2. **Pods can communicate with all other Pods** - Without NAT
3. **Nodes can communicate with all Pods** - And vice versa

```text
┌─────────────────────────────────────────────────────────────────┐
│               KUBERNETES NETWORKING MODEL                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Node 1                              Node 2                    │
│   ┌─────────────────────────┐        ┌─────────────────────────┐│
│   │ ┌─────────┐ ┌─────────┐ │        │ ┌─────────┐ ┌─────────┐ ││
│   │ │ Pod A   │ │ Pod B   │ │        │ │ Pod C   │ │ Pod D   │ ││
│   │ │10.244.  │ │10.244.  │ │        │ │10.244.  │ │10.244.  │ ││
│   │ │ 1.5     │ │ 1.6     │ │        │ │ 2.3     │ │ 2.4     │ ││
│   │ └────┬────┘ └────┬────┘ │        │ └────┬────┘ └────┬────┘ ││
│   │      └─────┬─────┘      │        │      └─────┬─────┘      ││
│   │            │            │        │            │            ││
│   └────────────┼────────────┘        └────────────┼────────────┘│
│                │                                  │             │
│                └──────────── CNI ─────────────────┘             │
│                         (Cluster Network)                       │
│                                                                 │
│   Pod A (10.244.1.5) can directly reach Pod D (10.244.2.4)      │
│   No NAT, no port mapping - just use the IP!                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### What is CNI?

**CNI** (Container Network Interface) is a plugin that sets up networking for pods. Kubernetes doesn't implement networking itself - it delegates to CNI plugins.

| CNI Plugin | Description | Use Case |
|------------|-------------|----------|
| **Flannel** | Simple, lightweight | Learning, development |
| **Calico** | Network policies, high performance | Production |
| **Cilium** | eBPF-based, advanced security | Modern production |
| **Weave** | Simple, mesh network | Small clusters |
| **kindnet** | Minimal (used by kind) | Local development |

Your kind cluster uses **kindnet** - a minimal CNI for local clusters.

### Hands-On: See Pod Networking

```bash
# Create some pods
kubectl create deployment web --image=nginx:alpine --replicas=3

# See pod IPs
kubectl get pods -o wide
```

Output:
```text
NAME                   READY   STATUS    IP           NODE
web-xxx-aaa            1/1     Running   10.244.1.5   playground-worker
web-xxx-bbb            1/1     Running   10.244.2.3   playground-worker2
web-xxx-ccc            1/1     Running   10.244.1.6   playground-worker
```

Each pod has a unique IP from the `10.244.x.x` range!

```bash
# Test pod-to-pod communication
kubectl run test --image=busybox --rm -it --restart=Never -- wget -qO- http://10.244.1.5

# Cleanup
kubectl delete deployment web
```

---

## Part 4: Kubernetes Services

### The Problem: Pod IPs Are Temporary

```text
┌─────────────────────────────────────────────────────────────────┐
│                    THE PROBLEM                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Pods come and go:                                             │
│                                                                 │
│   Before:                                                       │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│   │ web-abc     │  │ web-def     │  │ web-ghi     │             │
│   │ 10.244.1.5  │  │ 10.244.2.3  │  │ 10.244.1.6  │             │
│   └─────────────┘  └─────────────┘  └─────────────┘             │
│                                                                 │
│   After restart/scaling:                                        │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│   │ web-xyz     │  │ web-uvw     │  │ web-rst     │             │
│   │ 10.244.2.7  │  │ 10.244.1.9  │  │ 10.244.2.8  │  ← NEW IPs! │
│   └─────────────┘  └─────────────┘  └─────────────┘             │
│                                                                 │
│   If your app hardcodes 10.244.1.5, it will BREAK!              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### The Solution: Services

A **Service** provides a stable IP and DNS name that never changes, even as pods come and go.

```text
┌─────────────────────────────────────────────────────────────────┐
│                    KUBERNETES SERVICE                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Service: web-service                                          │
│   ClusterIP: 10.96.45.100 (NEVER changes!)                      │
│   DNS: web-service.default.svc.cluster.local                    │
│            │                                                    │
│            │ Routes to healthy pods                             │
│            ▼                                                    │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│   │ web-abc     │  │ web-def     │  │ web-ghi     │             │
│   │ 10.244.1.5  │  │ 10.244.2.3  │  │ 10.244.1.6  │             │
│   └─────────────┘  └─────────────┘  └─────────────┘             │
│                                                                 │
│   Client connects to: web-service:80                            │
│   Service load-balances to one of the pods                      │
│                                                                 │
│   Pods restart? Service IP stays the same!                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Service Types

| Type | Access From | Use Case |
|------|-------------|----------|
| **ClusterIP** | Inside cluster only | Internal services (default) |
| **NodePort** | Outside via node IP:port | Development, testing |
| **LoadBalancer** | External load balancer | Production (cloud) |
| **ExternalName** | DNS alias | External services |

---

### Service Type: ClusterIP (Default)

Only accessible from within the cluster.

```text
┌─────────────────────────────────────────────────────────────────┐
│                    ClusterIP SERVICE                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   OUTSIDE CLUSTER                                               │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  Your browser                                           │   │
│   │      │                                                  │   │
│   │      ╳  Cannot reach ClusterIP directly!                │   │
│   │                                                         │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   INSIDE CLUSTER                                                │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                                                         │   │
│   │   Frontend Pod ─────▶ backend-service:80 ─────▶ Backend │   │
│   │                       (ClusterIP: 10.96.x.x)            │   │
│   │                                                         │   │
│   │   Pods can reach ClusterIP services by name             │   │
│   │                                                         │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   Use for: Databases, internal APIs, backend services           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Hands-On: Create a ClusterIP Service

```bash
# Create a deployment
kubectl create deployment backend --image=nginx:alpine --replicas=3

# Expose it as a ClusterIP service
kubectl expose deployment backend --port=80

# See the service
kubectl get svc backend
```

Output:
```text
NAME      TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
backend   ClusterIP   10.96.45.100   <none>        80/TCP    5s
```

```bash
# Test from inside the cluster
kubectl run test --image=busybox --rm -it --restart=Never -- wget -qO- http://backend

# Or use the full DNS name
kubectl run test --image=busybox --rm -it --restart=Never -- wget -qO- http://backend.default.svc.cluster.local
```

---

### Service Type: NodePort

Opens a port on every node (30000-32767 range) for external access.

```text
┌─────────────────────────────────────────────────────────────────┐
│                    NodePort SERVICE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   OUTSIDE CLUSTER                                               │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  Your browser                                           │   │
│   │      │                                                  │   │
│   │      │  http://NODE-IP:30080                            │   │
│   │      │                                                  │   │
│   └──────┼──────────────────────────────────────────────────┘   │
│          │                                                      │
│          ▼                                                      │
│   ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│   │   Node 1     │  │   Node 2     │  │   Node 3     │          │
│   │   :30080     │  │   :30080     │  │   :30080     │          │
│   └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│          │                 │                 │                  │
│          └─────────────────┴─────────────────┘                  │
│                            │                                    │
│                    ┌───────┴───────┐                            │
│                    │    Service    │                            │
│                    │ ClusterIP:80  │                            │
│                    └───────┬───────┘                            │
│                            │                                    │
│                    ┌───────┴───────┐                            │
│                    │     Pods      │                            │
│                    └───────────────┘                            │
│                                                                 │
│   Any node IP + NodePort reaches your service                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Hands-On: Create a NodePort Service

```bash
# Create a deployment
kubectl create deployment web --image=nginx:alpine

# Expose as NodePort
kubectl expose deployment web --type=NodePort --port=80

# See the assigned NodePort
kubectl get svc web
```

Output:
```text
NAME   TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
web    NodePort   10.96.78.200   <none>        80:31234/TCP   5s
                                               ─────────
                                               Port 31234 on every node
```

```bash
# For kind, get the node IP
kubectl get nodes -o wide

# Access via node IP and NodePort
# curl <NODE-INTERNAL-IP>:31234

# For kind specifically, you might need to use port-forward instead
kubectl port-forward svc/web 8080:80 &
curl localhost:8080
```

---

### kubectl port-forward (Development Tool)

Creates a tunnel from your local machine to a pod or service. Great for debugging!

```text
┌─────────────────────────────────────────────────────────────────┐
│                   kubectl port-forward                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Your Mac                         Kubernetes Cluster           │
│   ┌─────────────────┐             ┌─────────────────────────┐   │
│   │                 │             │                         │   │
│   │ localhost:8080 ─┼── tunnel ──▶│ Service/Pod :80         │   │
│   │                 │  (kubectl)  │                         │   │
│   └─────────────────┘             └─────────────────────────┘   │
│                                                                 │
│   Bypasses NodePort/LoadBalancer - direct connection!           │
│   Great for: Debugging, accessing ClusterIP services            │
│   NOT for: Production traffic                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Hands-On: port-forward

```bash
# Forward to a service
kubectl port-forward svc/backend 8080:80 &

# Now access locally
curl localhost:8080

# Forward to a specific pod
kubectl port-forward pod/backend-xxx-yyy 8080:80 &

# Stop port-forward
pkill -f "kubectl port-forward"
```

---

### Service Type: LoadBalancer

Creates an external load balancer (cloud provider feature).

```text
┌─────────────────────────────────────────────────────────────────┐
│                  LoadBalancer SERVICE                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Internet                                                      │
│      │                                                          │
│      ▼                                                          │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │           Cloud Load Balancer                           │   │
│   │           (AWS ELB, GCP LB, Azure LB)                   │   │
│   │           External IP: 34.123.45.67                     │   │
│   └───────────────────────────┬─────────────────────────────┘   │
│                               │                                 │
│                               ▼                                 │
│   ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│   │    Node 1    │  │    Node 2    │  │    Node 3    │          │
│   └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│          └─────────────────┴─────────────────┘                  │
│                            │                                    │
│                    ┌───────┴───────┐                            │
│                    │     Pods      │                            │
│                    └───────────────┘                            │
│                                                                 │
│   Users access: http://34.123.45.67                             │
│                                                                 │
│   In kind (local), LoadBalancer won't get an external IP        │
│   Use NodePort or port-forward instead                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Part 5: DNS in Kubernetes

Every Service gets a DNS name automatically. CoreDNS handles this.

### DNS Name Formats

```text
┌─────────────────────────────────────────────────────────────────┐
│               KUBERNETES DNS NAMING                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Service: my-service                                           │
│   Namespace: default                                            │
│                                                                 │
│   DNS Names (all work):                                         │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                                                         │   │
│   │  my-service                      ← Same namespace only  │   │
│   │  my-service.default              ← With namespace       │   │
│   │  my-service.default.svc          ← With svc             │   │
│   │  my-service.default.svc.cluster.local  ← Fully qualified│   │
│   │                                                         │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   Cross-namespace access:                                       │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                                                         │   │
│   │  From namespace "frontend":                             │   │
│   │  → backend-api.backend-namespace                        │   │
│   │                                                         │   │
│   │  Must include namespace when crossing namespaces!       │   │
│   │                                                         │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Hands-On: Test DNS Resolution

```bash
# Create a service if you don't have one
kubectl create deployment web --image=nginx:alpine
kubectl expose deployment web --port=80

# Test DNS from a pod
kubectl run dns-test --image=busybox --rm -it --restart=Never -- nslookup web

# Output shows the ClusterIP
kubectl run dns-test --image=busybox --rm -it --restart=Never -- nslookup web.default.svc.cluster.local
```

### See CoreDNS

```bash
# CoreDNS runs in kube-system
kubectl get pods -n kube-system | grep coredns

# See the CoreDNS config
kubectl get configmap coredns -n kube-system -o yaml
```

---

## Part 6: Practical Networking Exercises

### Exercise 1: Full Stack Communication

```bash
# Create a "backend" service
kubectl create deployment backend --image=nginx:alpine
kubectl expose deployment backend --port=80

# Create a "frontend" that talks to backend
kubectl run frontend --image=busybox --rm -it --restart=Never -- sh

# Inside the frontend pod:
wget -qO- http://backend
# This works! Frontend reached backend by DNS name.
exit
```

### Exercise 2: Cross-Namespace Communication

```bash
# Create a namespace
kubectl create namespace production

# Deploy a service there
kubectl create deployment api --image=nginx:alpine -n production
kubectl expose deployment api --port=80 -n production

# From default namespace, try to reach it
kubectl run test --image=busybox --rm -it --restart=Never -- wget -qO- http://api
# FAILS! "api" not found

# Use the full name with namespace
kubectl run test --image=busybox --rm -it --restart=Never -- wget -qO- http://api.production
# WORKS!

# Cleanup
kubectl delete namespace production
```

### Exercise 3: Debug a Connection Issue

```bash
# Create a service with wrong selector (intentionally broken)
kubectl create deployment web --image=nginx:alpine

cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: broken-service
spec:
  selector:
    app: wrong-label  # This won't match any pods!
  ports:
  - port: 80
EOF

# Check endpoints (should be empty!)
kubectl get endpoints broken-service
# Output: broken-service   <none>   ← No endpoints!

# Fix it
kubectl patch svc broken-service -p '{"spec":{"selector":{"app":"web"}}}'

# Check again
kubectl get endpoints broken-service
# Output: broken-service   10.244.x.x:80   ← Now has endpoints!

# Cleanup
kubectl delete svc broken-service
kubectl delete deployment web
```

---

## Part 7: Troubleshooting Networking

### Common Issues and Fixes

| Problem | Diagnosis | Fix |
|---------|-----------|-----|
| Pod can't reach service | `kubectl get endpoints svc-name` | Check selector matches pod labels |
| DNS not resolving | `kubectl get pods -n kube-system | grep coredns` | Restart CoreDNS pods |
| Connection timeout | `kubectl describe svc svc-name` | Check ports match |
| Can't reach NodePort | Check firewall rules | Ensure port is open |

### Debugging Commands

```bash
# Check if service has endpoints
kubectl get endpoints <service-name>

# Check pod connectivity
kubectl exec -it <pod-name> -- ping <target-ip>
kubectl exec -it <pod-name> -- wget -qO- http://<service-name>

# Check DNS resolution
kubectl exec -it <pod-name> -- nslookup <service-name>

# See service details
kubectl describe svc <service-name>

# Check network policies (if any)
kubectl get networkpolicies

# View kube-proxy logs
kubectl logs -n kube-system -l k8s-app=kube-proxy
```

---

## Key Takeaways

1. **Ports** = Apartment numbers (identify services on a machine)
2. **0.0.0.0 vs localhost** = Accept all connections vs only local
3. **Every Pod gets an IP** = Direct communication, no NAT
4. **Services provide stable endpoints** = DNS names and ClusterIP don't change
5. **ClusterIP** = Internal only (default)
6. **NodePort** = External via node ports (30000-32767)
7. **LoadBalancer** = Cloud provider load balancer
8. **DNS** = Services accessible by name (`svc-name.namespace`)
9. **port-forward** = Dev tool to access any service locally

---

## Quick Reference

```bash
# Service types
kubectl expose deployment NAME --port=80                    # ClusterIP (default)
kubectl expose deployment NAME --type=NodePort --port=80    # NodePort
kubectl expose deployment NAME --type=LoadBalancer --port=80 # LoadBalancer

# Check service and endpoints
kubectl get svc
kubectl get endpoints

# Port forwarding
kubectl port-forward svc/NAME 8080:80
kubectl port-forward pod/NAME 8080:80

# DNS testing
kubectl run test --image=busybox --rm -it --restart=Never -- nslookup SERVICE

# Connectivity testing
kubectl run test --image=busybox --rm -it --restart=Never -- wget -qO- http://SERVICE:PORT

# See pod IPs
kubectl get pods -o wide
```

---

**Sources:**
- [Kubernetes Official: Port Forwarding](https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/)
- [Kubernetes Official: Services](https://kubernetes.io/docs/concepts/services-networking/service/)
- [Spacelift: Kubernetes Networking](https://spacelift.io/blog/kubernetes-networking)
- [Tigera: Kubernetes Networking Guide](https://www.tigera.io/learn/guides/kubernetes-networking/)
- [freeCodeCamp: Kubernetes Networking Tutorial](https://www.freecodecamp.org/news/kubernetes-networking-tutorial-for-developers/)

---

**Next:** [0.6 Mac Setup](./0.6_mac_setup.md)
