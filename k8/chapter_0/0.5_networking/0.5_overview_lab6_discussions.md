# Network Policies in Kubernetes

> Controlling which pods can talk to which other pods

**Prerequisites:**

- [0.5.2 What is a Service?](./0.5.2_what_is_a_service.md)
- [0.5.3 CoreDNS and Service Discovery](./0.5.3_coredns_and_service_discovery.md)

---

## The Problem: Open by Default

By default in Kubernetes:
- **Every pod can talk to every other pod** (across all namespaces)
- **Every pod can talk to the internet**
- There's no firewall between your apps

This is fine for learning, but in production:
- Your database pod shouldn't be accessible from the internet
- Your frontend shouldn't directly access your payment service
- A compromised pod shouldn't be able to reach everything else

---

## Why Kubernetes Allows All Communication by Default

### The Design Philosophy: "Open by Default, Restrict When Needed"

**1. Simplicity for Getting Started**
- New users can deploy apps and they "just work"
- No need to understand complex networking rules on day one
- Reduces barrier to entry for learning Kubernetes

**2. Microservices Need to Talk**
- In a microservices architecture, services constantly communicate
- Service A calls Service B, which calls Service C, etc.
- If everything was blocked by default, you'd spend hours writing "allow" rules before anything works

**3. The "Flat Network" Model**
- Kubernetes follows a principle: **every pod gets its own IP address**
- Every pod can reach every other pod directly (no NAT between pods)
- This mimics how VMs work on a traditional network

### Real-World Analogy: Office Building

| Approach | Analogy |
|----------|---------|
| **Kubernetes default** | All doors are unlocked. Anyone can walk into any room. Simple, but not secure. |
| **With Network Policies** | You install locks and keycards. Now you control who enters which rooms. |

### The Trade-off

| Open by Default | Closed by Default |
|-----------------|-------------------|
| Easy to start | Nothing works initially |
| Less config | Must whitelist everything |
| Must remember to add security | Secure from the start |

**Kubernetes chose "open by default"** because most clusters start in development/testing where security friction slows learning.

---

## What is a Network Policy?

A **Network Policy** is a Kubernetes resource that acts as a **firewall for pods**.

It controls:

| Direction | What it controls |
|-----------|------------------|
| **Ingress** | Who can send traffic **INTO** a pod |
| **Egress** | Where a pod can send traffic **OUT TO** |

### The Three Key Questions a Network Policy Answers

1. **Which pods does this policy apply to?** â†’ `podSelector`
2. **Who is allowed IN?** â†’ `ingress` rules
3. **Where can they go OUT?** â†’ `egress` rules

---

## Understanding Ingress and Egress

### Etymology (Word Origins)

Both words come from **Latin**:

| Word | Latin Root | Literal Meaning |
|------|------------|-----------------|
| **Ingress** | *ingredi* = "in" + "gradi" (to step/walk) | **To step IN** / Enter |
| **Egress** | *egredi* = "ex" (out) + "gradi" (to step/walk) | **To step OUT** / Exit |

### Real-World Usage

These are formal/technical terms used in:

**Architecture & Buildings:**
- "The building has two points of ingress" = two entrances
- "Emergency egress must be clearly marked" = emergency exits

**Legal/Property:**
- "Right of ingress and egress" = legal right to enter and leave a property

### In Networking Context

| Term | Direction | Memory Trick |
|------|-----------|--------------|
| **Ingress** | Traffic coming **IN** to something | **In**gress = **In**coming |
| **Egress** | Traffic going **OUT** from something | **E**gress = **E**xit |

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚             â”‚
   INGRESS          â”‚    POD      â”‚          EGRESS
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º      â”‚             â”‚      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
   (coming in)      â”‚             â”‚      (going out)
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Note: "Ingress" Has Two Meanings in Kubernetes

| Context | Meaning |
|---------|---------|
| **Network Policy Ingress** | Direction of traffic (incoming) |
| **Ingress Resource** | A Kubernetes object for HTTP routing from outside the cluster |

They share the same word because both deal with traffic "coming in" - but they're **completely different things**.

The Ingress Resource is covered separately in [Ingress Controllers](./0.5.5_ingress_controllers.md).

---

## What You Need for Network Policies to Work

Network Policies are just **rules on paper** - you need a **CNI plugin** that enforces them:

| CNI Plugin | Supports Network Policies? |
|------------|---------------------------|
| **Calico** | Yes |
| **Cilium** | Yes |
| **Weave Net** | Yes |
| **Flannel** | No (by default) |

**Important:** If your CNI doesn't support Network Policies, creating them has no effect!

---

## Lab 6: Network Policies in Action

### Setup: Create Two Namespaces

```bash
# Create namespaces
kubectl create namespace frontend
kubectl create namespace backend

# Deploy apps (using busybox for testing since nginx may not have wget)
kubectl run frontend --image=busybox -n frontend --command -- sleep 3600
kubectl run backend --image=nginx -n backend

# Expose backend as a service
kubectl expose pod backend --port=80 -n backend

# Wait for pods to be ready
kubectl wait --for=condition=Ready pod/frontend -n frontend
kubectl wait --for=condition=Ready pod/backend -n backend
```

### Test Connectivity (Should Work)

```bash
kubectl exec -it frontend -n frontend -- wget -qO- backend.backend.svc.cluster.local --timeout=3
```

At this point, frontend can reach backend because **no Network Policy exists** = all traffic allowed.

---

## Understanding the "Deny All Ingress" Policy

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
  namespace: backend
spec:
  podSelector: {}
  policyTypes:
  - Ingress
```

### Line by Line Breakdown

| Line | Meaning |
|------|---------|
| `apiVersion: networking.k8s.io/v1` | Network Policies live in the `networking.k8s.io` API group |
| `kind: NetworkPolicy` | We're creating a Network Policy resource |
| `name: deny-all-ingress` | Descriptive name (could be anything) |
| `namespace: backend` | This policy only applies to the `backend` namespace |
| `podSelector: {}` | **Empty = select ALL pods** in the namespace |
| `policyTypes: [Ingress]` | This policy controls **incoming** traffic |
| *(no ingress rules)* | **No rules = no exceptions = deny everything** |

### The Magic: What's MISSING

```yaml
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  # ingress:        â† THIS IS MISSING!
  #   - from: ...
```

**The rule:**
> Once a NetworkPolicy selects a pod, traffic is denied **unless explicitly allowed**

So this policy says:
- Select all pods in `backend` namespace
- Control their Ingress traffic
- Allow nothing (no rules = no exceptions)

**Result: Block ALL incoming traffic to all pods in backend namespace**

### Visual: Before and After

```
BEFORE policy:

  frontend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º backend
     âœ… allowed


AFTER policy:

  frontend â”€â”€â”€â”€â”€â”€â”€â”€Xâ”€â”€â”€â”€â”€â”€â–º backend
     ğŸš« blocked
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚ NetworkPolicyâ”‚
                         â”‚ deny-all    â”‚
                         â”‚ (no rules)  â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Apply and Test

```bash
# Apply the policy
cat <<EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
  namespace: backend
spec:
  podSelector: {}
  policyTypes:
  - Ingress
EOF

# Test again (should FAIL now - timeout)
kubectl exec -it frontend -n frontend -- wget -qO- backend.backend.svc.cluster.local --timeout=3
```

---

## Understanding the "Allow from Frontend" Policy

Now let's selectively allow traffic from the frontend namespace:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend
  namespace: backend
spec:
  podSelector: {}
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: frontend
  policyTypes:
  - Ingress
```

### What's Different?

| Deny All Policy | Allow Frontend Policy |
|-----------------|----------------------|
| No `ingress:` section | Has `ingress:` with rules |
| Blocks everything | Allows specific sources |

### The `ingress` Rules Explained

```yaml
ingress:
- from:
  - namespaceSelector:
      matchLabels:
        kubernetes.io/metadata.name: frontend
```

This says: "Allow ingress FROM pods in namespaces that have the label `kubernetes.io/metadata.name: frontend`"

**Note:** `kubernetes.io/metadata.name` is a built-in label that Kubernetes automatically adds to namespaces with their name.

### Apply and Test

```bash
# Apply the allow policy
cat <<EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend
  namespace: backend
spec:
  podSelector: {}
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: frontend
  policyTypes:
  - Ingress
EOF

# Test again (should work now!)
kubectl exec -it frontend -n frontend -- wget -qO- backend.backend.svc.cluster.local --timeout=3
```

---

## Important: Network Policies are ADDITIVE

- If NO policy exists â†’ all traffic allowed
- If ANY policy exists â†’ only explicitly allowed traffic gets through
- Multiple policies = union of all rules (if any policy allows it, it's allowed)

In our lab, we have TWO policies:
1. `deny-all-ingress` - blocks everything (no rules)
2. `allow-frontend` - allows from frontend namespace

Because policies are additive, the `allow-frontend` policy creates an exception to the deny-all.

---

## Viewing Network Policies

### Using kubectl

```bash
# List all network policies in all namespaces
kubectl get networkpolicies -A

# List in specific namespace
kubectl get networkpolicies -n backend

# See details of a specific policy
kubectl describe networkpolicy deny-all-ingress -n backend

# See the full YAML
kubectl get networkpolicy deny-all-ingress -n backend -o yaml
```

### Using Lens

Network Policies are not visible in Podman Desktop (it focuses on containers, not K8s networking). Use Lens instead:

```
Left Sidebar â†’ Network â†’ Network Policies
```

Or:

```
Left Sidebar â†’ Cluster â†’ Network â†’ Network Policies
```

Click on a policy to see:
- **Summary** - name, namespace, age
- **Spec** - the actual rules (podSelector, ingress, egress)
- **YAML tab** - full YAML definition

### Using K9s (Terminal UI)

```bash
k9s
# Then type: :networkpolicies or :np
```

---

## The "Default Deny" Pattern

In production, the common pattern is:

1. First, apply a **"deny all"** policy to each namespace
2. Then, add specific policies to allow only what you need

This is called **Zero Trust Networking** - trust nothing, verify everything.

```yaml
# Step 1: Deny all ingress (lock the doors)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-ingress
  namespace: my-namespace
spec:
  podSelector: {}
  policyTypes:
  - Ingress
---
# Step 2: Allow specific traffic (give keys to those who need them)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-specific-traffic
  namespace: my-namespace
spec:
  podSelector:
    matchLabels:
      app: my-app
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: allowed-client
```

---

## Cleanup

```bash
kubectl delete namespace frontend
kubectl delete namespace backend
```

---

## Quick Reference

### Common Policy Patterns

**Deny all ingress:**
```yaml
spec:
  podSelector: {}
  policyTypes:
  - Ingress
```

**Deny all egress:**
```yaml
spec:
  podSelector: {}
  policyTypes:
  - Egress
```

**Allow from specific namespace:**
```yaml
spec:
  podSelector: {}
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: allowed-namespace
```

**Allow from specific pods:**
```yaml
spec:
  podSelector:
    matchLabels:
      app: backend
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
```

**Allow specific port:**
```yaml
spec:
  podSelector: {}
  ingress:
  - ports:
    - protocol: TCP
      port: 80
```

### Useful Commands

```bash
# List policies
kubectl get networkpolicies -A

# Describe policy
kubectl describe networkpolicy <name> -n <namespace>

# Delete policy
kubectl delete networkpolicy <name> -n <namespace>

# Test connectivity
kubectl exec -it <pod> -n <namespace> -- wget -qO- <service>.<namespace>.svc.cluster.local --timeout=3
```

---

## Key Takeaways

1. **Kubernetes is open by default** - all pods can talk to all pods

2. **Network Policy = firewall for pods** - controls ingress (in) and egress (out)

3. **Ingress = incoming, Egress = outgoing** - from Latin "to step in/out"

4. **Empty podSelector `{}` = all pods** in that namespace

5. **No ingress rules = deny all ingress** - once a policy exists, only allowed traffic gets through

6. **Policies are additive** - if any policy allows traffic, it's allowed

7. **CNI must support it** - Calico, Cilium, Weave yes; Flannel no

8. **"Default Deny" pattern** - lock everything, then allow specific traffic

---

## What's Next?

- [Lab 7: Ingress Controllers](./0.5.5_ingress_controllers.md) - Expose services to the outside world
