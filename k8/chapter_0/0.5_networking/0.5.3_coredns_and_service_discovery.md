# CoreDNS and Kubernetes Service Discovery

> Understanding how pods find each other by name

**Prerequisites:**

- [0.5.1 What is a Deployment?](./0.5.1_what_is_a_deployment.md)
- [0.5.2 What is a Service?](./0.5.2_what_is_a_service.md)

---

## Complete Example: Putting It All Together

Let's walk through the full example that ties Deployments, Services, and DNS together:

```bash
# Step 1: Create a deployment (3 replicas)
kubectl create deployment web --image=nginx --replicas=3

# Step 2: Expose it with a ClusterIP service
kubectl expose deployment web --port=80

# Step 3: See the service
kubectl get svc web

# Step 4: Create a test pod to access the service
kubectl run test --image=busybox --restart=Never --command -- sleep 3600

# Step 5: Access service by DNS name (the magic!)
kubectl exec -it test -- wget -qO- web

# Step 6: Watch load balancing
kubectl exec -it test -- sh -c 'for i in 1 2 3 4 5; do wget -qO- web 2>/dev/null | head -1; done'
```

### What's happening step by step

```
┌─────────────────────────────────────────────────────────────────────┐
│                        KUBERNETES CLUSTER                            │
│                                                                      │
│  ┌──────────────┐         ┌─────────────────────────────────────┐   │
│  │              │         │           kube-system               │   │
│  │   test pod   │         │  ┌─────────────────────────────┐    │   │
│  │              │         │  │         CoreDNS              │    │   │
│  │  "wget web"  │────────▶│  │  "web" → 10.96.45.123       │    │   │
│  │              │  DNS    │  └─────────────────────────────┘    │   │
│  └──────────────┘         └─────────────────────────────────────┘   │
│         │                                                            │
│         │ HTTP to 10.96.45.123:80                                   │
│         ▼                                                            │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    Service: "web"                             │   │
│  │                ClusterIP: 10.96.45.123                        │   │
│  │                                                               │   │
│  │    ┌─────────────────────────────────────────────────────┐   │   │
│  │    │              kube-proxy (iptables rules)            │   │   │
│  │    │    DNAT to random pod: round-robin selection        │   │   │
│  │    └─────────────────────────────────────────────────────┘   │   │
│  │                     │         │         │                     │   │
│  │              ┌──────┘         │         └──────┐              │   │
│  │              ▼                ▼                ▼              │   │
│  │         ┌─────────┐     ┌─────────┐     ┌─────────┐          │   │
│  │         │  Pod 1  │     │  Pod 2  │     │  Pod 3  │          │   │
│  │         │  nginx  │     │  nginx  │     │  nginx  │          │   │
│  │         │10.244.  │     │10.244.  │     │10.244.  │          │   │
│  │         │ 1.10    │     │ 2.15    │     │ 1.22    │          │   │
│  │         └─────────┘     └─────────┘     └─────────┘          │   │
│  │                                                               │   │
│  │                   Deployment: "web"                           │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

| Step | What happens |
| ---- | ------------ |
| `wget web` | Test pod asks CoreDNS: "What IP is 'web'?" |
| CoreDNS | Returns 10.96.45.123 (the Service ClusterIP) |
| HTTP request | Goes to 10.96.45.123:80 |
| kube-proxy | Intercepts, rewrites destination to a Pod IP |
| Pod responds | nginx returns HTML |
| Load balancing | Each request may hit a different pod |

Now let's understand each component in detail.

---

## The Problem DNS Solves

Imagine the internet without DNS:

```text
You: "I want to visit Google"
Computer: "What's the IP address?"
You: "Uh... 142.250.80.46"
```

You'd have to memorize IP addresses for every website. That's impossible.

**DNS = Domain Name System** - it's a phone book that translates names to IP addresses.

```text
You type:    google.com
DNS says:    "That's 142.250.80.46"
Browser:     Connects to that IP
```

---

## DNS on Your Mac

Your Mac already uses DNS. Check it:

```bash
# See your DNS configuration
cat /etc/resolv.conf

# Example output:
# nameserver 192.168.1.1    ← Your router (it handles DNS)
```

When you type `google.com`, your Mac asks your router "What IP is google.com?" and the router figures it out (by asking upstream DNS servers).

```bash
# Try it yourself
nslookup google.com

# Or with more detail
dig google.com
```

---

## The Kubernetes Problem

In Kubernetes, Services get IP addresses:

```bash
kubectl get svc web
```

```text
NAME   TYPE        CLUSTER-IP     PORT(S)
web    ClusterIP   10.96.45.123   80/TCP
```

You *could* connect using `10.96.45.123`, but:

1. **IPs change** when services are recreated
2. **IPs are hard to remember**
3. **Other pods need a reliable way** to find services

We need DNS inside Kubernetes!

---

## CoreDNS = DNS Server for Kubernetes

CoreDNS is a DNS server that runs **inside** your cluster as pods.

```bash
# See CoreDNS pods
kubectl get pods -n kube-system -l k8s-app=kube-dns
```

```text
NAME                       READY   STATUS    RESTARTS   AGE
coredns-7d764666f9-5hvrt   1/1     Running   0          7d
coredns-7d764666f9-d8mmm   1/1     Running   0          7d
```

Its job is simple:

```text
Pod:     "What IP is 'web'?"
CoreDNS: "That's 10.96.45.123"
Pod:     "Thanks!" → connects
```

---

## How CoreDNS Knows About Services

```text
┌──────────────────────────────────────────────────────────────┐
│                                                              │
│   ┌──────────────────┐                                       │
│   │  Kubernetes API  │  ← Stores all services and their IPs  │
│   └────────┬─────────┘                                       │
│            │                                                 │
│            │ watches (constantly syncing)                    │
│            ▼                                                 │
│   ┌──────────────────┐                                       │
│   │     CoreDNS      │  ← Learns: "web" = 10.96.45.123       │
│   └────────┬─────────┘                                       │
│            │                                                 │
│            │ answers DNS queries                             │
│            ▼                                                 │
│   ┌──────────────────┐                                       │
│   │    Your Pods     │  ← Ask: "where is web?"               │
│   └──────────────────┘                                       │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

**Key insight:** CoreDNS watches the Kubernetes API to learn about services. If it can't reach the API, it can't answer DNS queries.

---

## How Pods Know to Use CoreDNS

Every pod gets a `/etc/resolv.conf` file automatically:

```bash
kubectl exec -it <any-pod> -- cat /etc/resolv.conf
```

```text
search default.svc.cluster.local svc.cluster.local cluster.local
nameserver 10.96.0.10
options ndots:5
```

Breaking this down:

| Line | Meaning |
|------|---------|
| `nameserver 10.96.0.10` | CoreDNS service IP - all DNS queries go here |
| `search default.svc...` | Suffixes to try when you use short names |
| `options ndots:5` | How to decide if a name needs suffixes |

---

## DNS Name Formats

You can reach a service using different name formats:

```bash
# Short name (within same namespace)
wget web

# With namespace
wget web.default

# Fully qualified domain name (FQDN)
wget web.default.svc.cluster.local
```

The `search` line in resolv.conf makes short names work:

```text
You type:     web
DNS tries:    web.default.svc.cluster.local  ← Found!
```

---

## Hands-On: See DNS in Action

### Step 1: Create a service

```bash
kubectl create deployment web --image=nginx
kubectl expose deployment web --port=80
```

### Step 2: Create a test pod

```bash
kubectl run test --image=busybox --restart=Never --command -- sleep 3600
kubectl wait --for=condition=Ready pod/test
```

### Step 3: Check DNS configuration

```bash
kubectl exec -it test -- cat /etc/resolv.conf
```

### Step 4: Resolve the service name

```bash
# Using nslookup
kubectl exec -it test -- nslookup web

# Expected output:
# Server:    10.96.0.10
# Address:   10.96.0.10:53
#
# Name:      web.default.svc.cluster.local
# Address:   10.96.X.X
```

### Step 5: Access the service

```bash
kubectl exec -it test -- wget -qO- web
```

### Cleanup

```bash
kubectl delete deployment web
kubectl delete svc web
kubectl delete pod test
```

---

## Troubleshooting: "bad address" Error

If you see this error:

```text
wget: bad address 'web'
```

It means DNS resolution failed. The pod asked "where is web?" and got no answer.

### Step 1: Check CoreDNS pods

```bash
kubectl get pods -n kube-system -l k8s-app=kube-dns
```

They should show `Running` and `1/1` Ready.

### Step 2: Check CoreDNS logs

```bash
kubectl logs -n kube-system -l k8s-app=kube-dns --tail=30
```

**Healthy logs look like:**
```text
.:53
[INFO] plugin/reload: Running configuration SHA512 = ...
CoreDNS-1.x.x
```

**Unhealthy logs show:**
```text
[ERROR] plugin/kubernetes: Failed to watch
[INFO] plugin/ready: Plugins not ready: "kubernetes"
```

This means CoreDNS can't reach the Kubernetes API.

### Step 3: Try the fully qualified name

```bash
kubectl exec -it test -- wget -qO- web.default.svc.cluster.local
```

If this also fails, DNS is definitely broken.

### Step 4: Check pod's DNS configuration

```bash
kubectl exec -it test -- cat /etc/resolv.conf
```

Should show `nameserver 10.96.0.10` (CoreDNS IP).

---

## Common CoreDNS Issues and Fixes

### Issue: CoreDNS can't reach Kubernetes API

**Symptoms:**
```text
[ERROR] plugin/kubernetes: Failed to watch
[INFO] plugin/ready: Plugins not ready: "kubernetes"
```

**Cause:** Network issue between CoreDNS pods and API server. Common after laptop sleep or Docker restart.

**Fix:**
```bash
# Restart CoreDNS
kubectl rollout restart deployment coredns -n kube-system

# Wait for it to be ready
kubectl rollout status deployment coredns -n kube-system
```

### Issue: CoreDNS pods in CrashLoopBackOff

**Symptoms:**
```bash
kubectl get pods -n kube-system -l k8s-app=kube-dns
# Shows: CrashLoopBackOff or Error
```

**Fix:**
```bash
# Check logs for the actual error
kubectl logs -n kube-system -l k8s-app=kube-dns

# Usually a restart fixes it
kubectl rollout restart deployment coredns -n kube-system
```

### Issue: DNS works for external domains but not services

**Symptoms:**
```bash
kubectl exec -it test -- nslookup google.com  # Works
kubectl exec -it test -- nslookup web         # Fails
```

**Cause:** CoreDNS is running but not synced with Kubernetes API.

**Fix:**
```bash
kubectl rollout restart deployment coredns -n kube-system
```

### Issue: Kind cluster networking broken after restart

**Symptoms:** Multiple networking issues, not just DNS.

**Fix:**
```bash
# Restart Kind nodes (Docker containers)
docker restart $(docker ps -q --filter "name=kind")

# Wait 30 seconds, then check
kubectl get pods -n kube-system
```

**Nuclear option:**
```bash
kind delete cluster
kind create cluster --config kind-config.yaml
```

---

## CoreDNS Architecture in Kind

```text
┌─────────────────────────────────────────────────────────────┐
│                     Kind Cluster                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────┐     ┌─────────────────┐               │
│  │  Control Plane  │     │   Worker Node   │               │
│  │  (Docker)       │     │   (Docker)      │               │
│  │                 │     │                 │               │
│  │  ┌───────────┐  │     │  ┌───────────┐  │               │
│  │  │ API Server│  │     │  │  Your Pod │  │               │
│  │  └─────┬─────┘  │     │  └─────┬─────┘  │               │
│  │        │        │     │        │        │               │
│  │        │        │     │        │ DNS    │               │
│  │        │        │     │        │ query  │               │
│  │        │        │     │        ▼        │               │
│  │        │        │     │  ┌───────────┐  │               │
│  │        │ watch  │     │  │  CoreDNS  │  │               │
│  │        └────────┼─────┼──┤  Pod      │  │               │
│  │                 │     │  └───────────┘  │               │
│  └─────────────────┘     └─────────────────┘               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

CoreDNS pods run on worker nodes but need to reach the API server on the control plane. When Docker networking gets confused (after sleep/restart), this connection breaks.

---

## Quick Reference

### Check DNS health

```bash
# CoreDNS pods running?
kubectl get pods -n kube-system -l k8s-app=kube-dns

# CoreDNS logs clean?
kubectl logs -n kube-system -l k8s-app=kube-dns --tail=20

# Can resolve services?
kubectl exec -it <pod> -- nslookup <service-name>
```

### Fix DNS issues

```bash
# Restart CoreDNS (fixes most issues)
kubectl rollout restart deployment coredns -n kube-system

# Restart Kind nodes (fixes networking issues)
docker restart $(docker ps -q --filter "name=kind")
```

### DNS debugging commands

```bash
# Check pod's DNS config
kubectl exec -it <pod> -- cat /etc/resolv.conf

# Resolve a name
kubectl exec -it <pod> -- nslookup <name>

# See CoreDNS configuration
kubectl get configmap coredns -n kube-system -o yaml
```

---

## Key Takeaways

1. **DNS translates names to IPs** - so you don't have to remember `10.96.45.123`

2. **CoreDNS is the DNS server in Kubernetes** - it runs as pods in `kube-system`

3. **CoreDNS watches the API** - it learns about services by watching Kubernetes

4. **If CoreDNS can't reach the API, DNS breaks** - "bad address" errors

5. **`kubectl rollout restart deployment coredns -n kube-system`** - fixes most DNS issues

6. **Kind networking can break after sleep** - restart CoreDNS or Docker containers

---

## What's Next?

- [Lab 5: DNS Deep Dive](./0.5_overview.md#lab-5-dns-deep-dive-25-min) - More hands-on DNS exploration
- [Lab 6: Network Policies](./0.5_overview.md#lab-6-network-policies-30-min) - Control traffic between pods
