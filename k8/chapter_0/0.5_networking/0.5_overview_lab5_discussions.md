# Lab 5: Kubernetes DNS and Service Discovery

## Overview

This lab explores how CoreDNS provides service discovery inside a Kubernetes cluster.

---

## Part 1: DNS Fundamentals

### What is DNS?

**DNS = Domain Name System**

It's like a phone book for the internet. Humans remember names, computers need numbers.

```
You type:     google.com
Computer needs: 142.250.193.14
```

**DNS translates names → IP addresses**

### Why Do We Need It?

Without DNS:
```bash
# You'd have to memorize this
curl http://142.250.193.14
```

With DNS:
```bash
# Much easier
curl http://google.com
```

### How DNS Works (Basic Flow)

```
┌──────────┐   1. "What's google.com?"   ┌────────────┐
│   You    │ ───────────────────────────▶│ DNS Server │
│          │                              │            │
│          │ ◀─────────────────────────── │            │
└──────────┘   2. "It's 142.250.193.14"  └────────────┘
                                                │
                        3. Now connect          │
                           to that IP           │
                              │                 │
                              ▼                 │
                       ┌────────────┐          │
                       │  Google's  │          │
                       │   Server   │          │
                       │142.250.193.│          │
                       │     14     │          │
                       └────────────┘          │
```

### Real World Analogy

| Concept | Real World | DNS |
|---------|------------|-----|
| Name | "Pizza Hut" | `google.com` |
| Address | "123 Main Street" | `142.250.193.14` |
| Phone Book | Yellow Pages | DNS Server |
| Looking up | "Where is Pizza Hut?" | "What IP is google.com?" |

---

## Part 2: What is `/etc/resolv.conf`?

It's a **configuration file** that answers one question:

> "When I need to look up a name, **who do I ask?**"

### The Name Breakdown

```
/etc/resolv.conf

/etc/        → System configuration folder
resolv       → "resolve" (convert name → IP)
.conf        → Configuration file
```

---

## Part 3: Lab Setup

### Create Resources

```bash
# Create a deployment and service
kubectl create deployment web --image=nginx
kubectl expose deployment web --port=80

# Create test pod with DNS tools
kubectl run dnstest --image=busybox:1.36 --restart=Never --command -- sleep 3600
```

This creates:
- A **Deployment** named `web` running nginx
- A **Service** named `web` that exposes it on port 80
- A **test pod** with DNS tools (`nslookup`) that stays alive for 1 hour

---

## Part 4: Examining DNS Configuration

### Check the DNS Config

```bash
kubectl exec -it dnstest -- cat /etc/resolv.conf
```

**Output:**
```
search default.svc.cluster.local svc.cluster.local cluster.local dns.podman
nameserver 10.96.0.10
options ndots:5
```

### Breaking Down Each Line

#### Line 1: `search`

**"Add these suffixes to short names"**

When you query just `web`, the system tries:

```
Step 1: web.default.svc.cluster.local   ← Try first
Step 2: web.svc.cluster.local           ← Then this
Step 3: web.cluster.local               ← Then this
Step 4: web.dns.podman                  ← Then this (Podman-specific)
Step 5: web                             ← Finally, exact name
```

#### Line 2: `nameserver 10.96.0.10`

**"Who do I ask?"**

All DNS queries go to CoreDNS at this IP.

#### Line 3: `options ndots:5`

**"When to use search domains"**

If the name has fewer than 5 dots → use search domains first.

| Name | Dots | What Happens |
|------|------|--------------|
| `web` | 0 | Use search domains ✓ |
| `google.com` | 1 | Use search domains ✓ |
| `api.google.com` | 2 | Use search domains ✓ |
| `a.b.c.d.e.f` | 5 | Skip search, query directly |

### Summary Table

| Component | What It Does | Pod's Value |
|-----------|--------------|-------------|
| `nameserver` | DNS server to ask | `10.96.0.10` (CoreDNS) |
| `search` | Suffixes to try | Kubernetes namespaces |
| `ndots` | When to use search | If name has < 5 dots |

---

## Part 5: Comparing Pod DNS vs macOS DNS

### macOS `/etc/resolv.conf`

```bash
cat /etc/resolv.conf
```

**Output:**
```
#
# macOS Notice
#
# This file is not consulted for DNS hostname resolution...
#
nameserver 2401:4900:50:9::7dd
nameserver 2401:4900:50:9::8
nameserver 192.168.1.1
```

**Important:** macOS **ignores** this file! Use `scutil --dns` to see actual DNS.

### Side by Side Comparison

| Aspect | Kubernetes Pod | macOS |
|--------|----------------|-------|
| **File** | `/etc/resolv.conf` | `/etc/resolv.conf` (but ignored!) |
| **Actually used?** | ✅ Yes | ❌ No — macOS uses `scutil --dns` |
| **DNS Server** | `10.96.0.10` (CoreDNS) | Your router + ISP |
| **Search domains** | Kubernetes namespaces | None configured |
| **Purpose** | Service discovery in cluster | Internet DNS |

### Visual Comparison

```
┌─────────────────────────────────────────────────────────────────┐
│                        YOUR MAC                                  │
│                                                                  │
│   App queries "google.com"                                       │
│          │                                                       │
│          ▼                                                       │
│   ┌──────────────┐      ┌─────────────────┐                     │
│   │ macOS DNS    │ ───▶ │ 192.168.1.1     │ ───▶ Internet       │
│   │ Resolver     │      │ (your router)   │                     │
│   └──────────────┘      └─────────────────┘                     │
│                                                                  │
│   ┌──────────────────────────────────────────────────────────┐  │
│   │                 KUBERNETES CLUSTER                        │  │
│   │                 (inside Podman)                           │  │
│   │                                                           │  │
│   │   Pod queries "web"                                       │  │
│   │          │                                                │  │
│   │          ▼                                                │  │
│   │   ┌──────────────┐      ┌─────────────────┐              │  │
│   │   │ Pod's        │ ───▶ │ 10.96.0.10      │              │  │
│   │   │ resolv.conf  │      │ (CoreDNS)       │              │  │
│   │   └──────────────┘      └─────────────────┘              │  │
│   │                                │                          │  │
│   │                    ┌───────────┴───────────┐             │  │
│   │                    ▼                       ▼             │  │
│   │              Internal name?          External name?       │  │
│   │              "web" → ClusterIP       "google.com" →       │  │
│   │                                      forward to router    │  │
│   └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Part 6: Service Discovery in Action

### Resolving Service Names

```bash
kubectl exec -it dnstest -- nslookup web
```

**Output:**
```
Server:         10.96.0.10
Address:        10.96.0.10:53

** server can't find web.svc.cluster.local: NXDOMAIN
** server can't find web.cluster.local: NXDOMAIN

Name:   web.default.svc.cluster.local
Address: 10.96.3.19

** server can't find web.cluster.local: NXDOMAIN
** server can't find web.svc.cluster.local: NXDOMAIN
** server can't find web.dns.podman: NXDOMAIN
** server can't find web.dns.podman: NXDOMAIN
```

### What is NXDOMAIN?

**NXDOMAIN = Non-Existent Domain**

It's a DNS response that means: "This name does not exist."

| Response | Meaning |
|----------|---------|
| **IP Address** (e.g., `10.96.3.19`) | ✅ "Found it! Here's the address." |
| **NXDOMAIN** | ❌ "This name doesn't exist anywhere." |

### Understanding the Output

DNS tries **each suffix** from search domains:

| Query Tried | Result | Meaning |
|-------------|--------|---------|
| `web.default.svc.cluster.local` | ✅ **Found! IP: 10.96.3.19** | Service exists in `default` namespace |
| `web.svc.cluster.local` | ❌ NXDOMAIN | Not found |
| `web.cluster.local` | ❌ NXDOMAIN | Not found |
| `web.dns.podman` | ❌ NXDOMAIN | Not found |

**The important part:**
```
Name:   web.default.svc.cluster.local
Address: 10.96.3.19
```

Your `web` service exists in the `default` namespace with ClusterIP `10.96.3.19`.

---

## Part 7: The BusyBox DNS Bug

### The Problem

```bash
kubectl exec -it dnstest -- nslookup kubernetes.default
```

**Output:**
```
Server:         10.96.0.10
Address:        10.96.0.10:53

Non-authoritative answer:

** server can't find kubernetes.default: NXDOMAIN
```

But this works:

```bash
kubectl exec -it dnstest -- nslookup kubernetes
```

**Output:**
```
Server:         10.96.0.10
Address:        10.96.0.10:53

Name:   kubernetes.default.svc.cluster.local
Address: 10.96.0.1
```

### Why Does `kubernetes.default` Fail?

| Query | Dots | Found? |
|-------|------|--------|
| `kubernetes` | 0 | ✅ Yes |
| `kubernetes.default` | 1 | ❌ No |

When you query `kubernetes` (0 dots):
```
kubernetes + .default.svc.cluster.local = kubernetes.default.svc.cluster.local ✅
```

When you query `kubernetes.default` (1 dot):
```
kubernetes.default + .default.svc.cluster.local = kubernetes.default.default.svc.cluster.local ❌
kubernetes.default + .svc.cluster.local = kubernetes.default.svc.cluster.local ✅ (but BusyBox doesn't try it!)
```

### Root Cause: BusyBox Bug

This is a **known BusyBox bug**. From GitHub issues:

> "After months of using busybox in Kubernetes, users encountered a strange bug: if they omit adding the `.svc.cluster.local` suffix to nslookup, e.g., if they try to resolve `kubernetes.default`, it will end up with a NXDOMAIN answer."
>
> "Note that from any other container than busybox, **it works fine**."

**BusyBox handles search domains differently when there's a dot in the query.**

### Comparison Across Images

| Image | `nslookup kubernetes.default` | `nslookup kubernetes` |
|-------|------------------------------|----------------------|
| BusyBox (newer versions) | ❌ NXDOMAIN | ✅ Works |
| Alpine | ✅ Works | ✅ Works |
| Ubuntu/Debian | ✅ Works | ✅ Works |

### Visual Explanation

```
┌────────────────────────────────────────────────────────────┐
│              Using: busybox:1.36                            │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  "kubernetes" (0 dots)                                      │
│   └──▶ BusyBox correctly tries search domains               │
│   └──▶ Finds kubernetes.default.svc.cluster.local ✅        │
│                                                             │
│  "kubernetes.default" (1 dot)                               │
│   └──▶ BusyBox bug: doesn't try search domains properly     │
│   └──▶ NXDOMAIN ❌                                          │
│                                                             │
└────────────────────────────────────────────────────────────┘
```

### Workarounds

1. **Use full FQDN:**
   ```bash
   nslookup kubernetes.default.svc.cluster.local
   ```

2. **Use older BusyBox:**
   ```bash
   kubectl run dnstest --image=busybox:1.28 --restart=Never --command -- sleep 3600
   ```

3. **Use Alpine instead:**
   ```bash
   kubectl run dnstest --image=alpine --restart=Never --command -- sleep 3600
   kubectl exec -it dnstest -- nslookup kubernetes.default
   ```

---

## Part 8: Kubernetes Core Concepts

### What is CoreDNS?

**CoreDNS = The DNS server inside your Kubernetes cluster**

Remember how we said DNS translates names → IP addresses? CoreDNS is the **program** that does this translation for your cluster.

#### Simple Analogy

| Real World | Kubernetes |
|------------|------------|
| Phone book | CoreDNS |
| Person looking up numbers | Your pods |
| "What's Pizza Hut's number?" | "What's the IP of `web` service?" |

#### Where Does CoreDNS Run?

It runs as **pods** inside your cluster:

```bash
kubectl get pods -n kube-system -l k8s-app=kube-dns
```

```
┌─────────────────────────────────────────┐
│           kube-system namespace          │
│                                          │
│   ┌─────────────┐    ┌─────────────┐    │
│   │  CoreDNS    │    │  CoreDNS    │    │
│   │   Pod 1     │    │   Pod 2     │    │
│   └─────────────┘    └─────────────┘    │
│                                          │
│         (2 copies for reliability)       │
└─────────────────────────────────────────┘
```

#### What Does CoreDNS Do?

```
┌──────────┐                      ┌──────────┐
│ Your Pod │  "IP of web?"       │ CoreDNS  │
│          │ ──────────────────▶ │          │
│          │                      │          │
│          │ ◀────────────────── │          │
│          │  "10.96.3.19"       │          │
└──────────┘                      └──────────┘
```

1. Pod asks: "What's the IP of `web`?"
2. CoreDNS knows all services in the cluster
3. CoreDNS replies: "It's `10.96.3.19`"

---

### What is a ConfigMap?

**ConfigMap = A way to store configuration data in Kubernetes**

Think of it as a **settings file** stored in Kubernetes.

#### Simple Analogy

| Real World | Kubernetes |
|------------|------------|
| `.env` file | ConfigMap |
| `config.json` | ConfigMap |
| Settings file | ConfigMap |

#### Why Do We Need ConfigMaps?

**Problem:** How do you give settings to a container?

**Bad way:** Hardcode settings inside the container image
```dockerfile
# Rebuilding image every time settings change = bad
ENV DATABASE_URL=postgres://localhost:5432
```

**Good way:** Store settings in a ConfigMap, inject into container
```yaml
# Change settings without rebuilding image = good
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config
data:
  DATABASE_URL: "postgres://localhost:5432"
```

#### ConfigMap Structure

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config        # Name of this ConfigMap
  namespace: default     # Where it lives
data:
  key1: "value1"         # Simple key-value
  key2: "value2"
  config.json: |         # Or entire files
    {
      "setting": true
    }
```

#### Visual: How ConfigMaps Work

```
┌─────────────────────────────────────────────────────────────┐
│                      Kubernetes                              │
│                                                              │
│   ┌─────────────────┐                                       │
│   │    ConfigMap    │                                       │
│   │   "my-config"   │                                       │
│   │                 │                                       │
│   │  DB_HOST=mysql  │                                       │
│   │  DB_PORT=3306   │                                       │
│   └────────┬────────┘                                       │
│            │                                                 │
│            │  Inject settings                                │
│            ▼                                                 │
│   ┌─────────────────┐                                       │
│   │      Pod        │                                       │
│   │                 │                                       │
│   │  Container sees:│                                       │
│   │  DB_HOST=mysql  │                                       │
│   │  DB_PORT=3306   │                                       │
│   └─────────────────┘                                       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### CoreDNS + ConfigMap Together

CoreDNS uses a ConfigMap named `coredns` to store its settings:

```bash
kubectl get configmap coredns -n kube-system -o yaml
```

```
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│   ┌─────────────────┐         ┌─────────────────┐           │
│   │    ConfigMap    │         │   CoreDNS Pod   │           │
│   │    "coredns"    │ ──────▶ │                 │           │
│   │                 │  reads  │  Uses these     │           │
│   │  Corefile: |    │         │  settings to    │           │
│   │    .:53 {       │         │  answer DNS     │           │
│   │      kubernetes │         │  queries        │           │
│   │      forward    │         │                 │           │
│   │    }            │         │                 │           │
│   └─────────────────┘         └─────────────────┘           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

### What are Namespaces?

**Namespace = A folder to organize your Kubernetes stuff**

#### Simple Analogy

| Real World | Kubernetes |
|------------|------------|
| Folders on your computer | Namespaces |
| `Documents/`, `Downloads/`, `Projects/` | `default`, `kube-system`, `production` |

```
Your Computer:
├── Documents/
│   ├── resume.pdf
│   └── notes.txt
├── Downloads/
│   └── movie.mp4
└── Projects/
    └── app.js

Kubernetes Cluster:
├── default/
│   ├── web (deployment)
│   └── dnstest (pod)
├── kube-system/
│   ├── coredns (pods)
│   └── kube-dns (service)
└── production/
    └── api (deployment)
```

#### Why Do We Need Namespaces?

**Problem:** Everything in one place = messy

```
# Without namespaces (chaos!)
web-frontend
web-backend
web-database
api-frontend
api-backend
api-database
monitoring-grafana
monitoring-prometheus
... 100 more things
```

**Solution:** Organize with namespaces

```
namespace: web/
  ├── frontend
  ├── backend
  └── database

namespace: api/
  ├── frontend
  ├── backend
  └── database

namespace: monitoring/
  ├── grafana
  └── prometheus
```

#### Default Namespaces in Kubernetes

Every cluster comes with these:

| Namespace | Purpose |
|-----------|---------|
| `default` | Where your stuff goes if you don't specify |
| `kube-system` | Kubernetes internal components (CoreDNS, etc.) |
| `kube-public` | Publicly readable data |
| `kube-node-lease` | Node heartbeat tracking |

#### See All Namespaces

```bash
kubectl get namespaces
```

Output:
```
NAME              STATUS   AGE
default           Active   10d
kube-node-lease   Active   10d
kube-public       Active   10d
kube-system       Active   10d
```

#### Visual: Cluster Namespaces

```
┌─────────────────────────────────────────────────────────────────┐
│                     YOUR KUBERNETES CLUSTER                      │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                 namespace: kube-system                      │ │
│  │                 (Kubernetes internals)                      │ │
│  │                                                             │ │
│  │   ┌─────────┐  ┌─────────┐  ┌───────────┐                  │ │
│  │   │ CoreDNS │  │ CoreDNS │  │ kube-dns  │                  │ │
│  │   │  Pod 1  │  │  Pod 2  │  │  Service  │                  │ │
│  │   └─────────┘  └─────────┘  │10.96.0.10 │                  │ │
│  │                              └───────────┘                  │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                 namespace: default                          │ │
│  │                 (Your stuff)                                │ │
│  │                                                             │ │
│  │   ┌─────────┐  ┌─────────┐  ┌───────────┐                  │ │
│  │   │ dnstest │  │   web   │  │    web    │                  │ │
│  │   │   Pod   │  │  Deploy │  │  Service  │                  │ │
│  │   └─────────┘  └─────────┘  │10.96.3.19 │                  │ │
│  │                              └───────────┘                  │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### How Namespaces Affect DNS

The DNS name includes the namespace:

```
<service>.<namespace>.svc.cluster.local

web.default.svc.cluster.local         ← "web" service in "default" namespace
kubernetes.default.svc.cluster.local  ← "kubernetes" service in "default" namespace
kube-dns.kube-system.svc.cluster.local ← "kube-dns" service in "kube-system" namespace
```

#### Working with Namespaces

```bash
# List resources in default namespace
kubectl get pods

# List resources in specific namespace
kubectl get pods -n kube-system

# List resources in ALL namespaces
kubectl get pods -A
```

#### Creating a Namespace

```bash
# Create new namespace
kubectl create namespace my-app

# Create pod in that namespace
kubectl run nginx --image=nginx -n my-app

# See it
kubectl get pods -n my-app
```

---

### What are Labels?

**Label = A tag/sticker you put on Kubernetes resources**

#### Simple Analogy

| Real World | Kubernetes |
|------------|------------|
| Stickers on boxes | Labels on pods |
| "Fragile", "Kitchen", "Books" | `app=web`, `env=prod`, `team=backend` |

```
Moving boxes:
┌─────────┐  ┌─────────┐  ┌─────────┐
│  Box 1  │  │  Box 2  │  │  Box 3  │
│         │  │         │  │         │
│ [Kitchen]  │ [Kitchen]  │ [Bedroom]
│ [Fragile]  │         │  │         │
└─────────┘  └─────────┘  └─────────┘

"Give me all Kitchen boxes" → Box 1, Box 2
"Give me all Fragile boxes" → Box 1
```

#### Labels in Kubernetes

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:              # ← Labels go here
    app: web
    env: production
    team: frontend
```

A pod can have **multiple labels** (key-value pairs).

#### Why Do We Need Labels?

**Problem:** How do you find specific pods among hundreds?

```
kubectl get pods

NAME                      READY   STATUS
coredns-5dd5756b68-abc    1/1     Running
coredns-5dd5756b68-xyz    1/1     Running
nginx-7b4f8d7-111         1/1     Running
nginx-7b4f8d7-222         1/1     Running
redis-6c8b9d-aaa          1/1     Running
mysql-8f7d6e-bbb          1/1     Running
... 100 more pods
```

**Solution:** Use labels to filter

```bash
# Get only nginx pods
kubectl get pods -l app=nginx

# Get only production pods
kubectl get pods -l env=production

# Get CoreDNS pods
kubectl get pods -l k8s-app=kube-dns
```

#### Understanding the CoreDNS Label Command

```bash
kubectl get pods -n kube-system -l k8s-app=kube-dns
```

| Part | Meaning |
|------|---------|
| `kubectl get pods` | List pods |
| `-n kube-system` | In the `kube-system` namespace |
| `-l k8s-app=kube-dns` | Only pods with label `k8s-app=kube-dns` |

#### See the Labels Yourself

```bash
# Show pods WITH their labels
kubectl get pods -n kube-system --show-labels
```

Output:
```
NAME                       READY   STATUS    LABELS
coredns-5dd5756b68-abc     1/1     Running   k8s-app=kube-dns,pod-template-hash=5dd5756b68
coredns-5dd5756b68-xyz     1/1     Running   k8s-app=kube-dns,pod-template-hash=5dd5756b68
etcd-control-plane         1/1     Running   component=etcd,tier=control-plane
```

#### Visual: How Label Filtering Works

```
┌─────────────────────────────────────────────────────────────────┐
│                     kube-system namespace                        │
│                                                                  │
│   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐          │
│   │  CoreDNS    │   │  CoreDNS    │   │    etcd     │          │
│   │   Pod 1     │   │   Pod 2     │   │    Pod      │          │
│   │             │   │             │   │             │          │
│   │ k8s-app=    │   │ k8s-app=    │   │ component=  │          │
│   │  kube-dns   │   │  kube-dns   │   │  etcd       │          │
│   └─────────────┘   └─────────────┘   └─────────────┘          │
│         ▲                 ▲                                     │
│         │                 │                                     │
│         └────────┬────────┘                                     │
│                  │                                              │
│     kubectl get pods -l k8s-app=kube-dns                       │
│     "Give me pods with this label"                             │
│                  │                                              │
│                  ▼                                              │
│         Returns: Pod 1, Pod 2 (not etcd)                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### Common Label Examples

| Label | Meaning |
|-------|---------|
| `app=nginx` | This is the nginx application |
| `env=production` | This runs in production |
| `team=backend` | Owned by backend team |
| `k8s-app=kube-dns` | Kubernetes DNS component |
| `version=v2` | Version 2 of the app |

#### Why `k8s-app` Instead of Just `app`?

`k8s-app` is a convention for **Kubernetes system components**.

| Label | Used For |
|-------|----------|
| `app=` | Your applications |
| `k8s-app=` | Kubernetes internal components |

It's just a naming convention to separate your stuff from Kubernetes stuff.

#### Label Commands Summary

```bash
# See all labels on CoreDNS pods
kubectl get pods -n kube-system -l k8s-app=kube-dns --show-labels

# See all pods in kube-system (no filter)
kubectl get pods -n kube-system

# Filter by multiple labels
kubectl get pods -l app=web,env=production
```

---

### Understanding the CoreDNS Corefile

The CoreDNS ConfigMap contains the **Corefile** — the configuration that controls how CoreDNS behaves.

#### View the ConfigMap

```bash
kubectl get configmap coredns -n kube-system -o yaml
```

#### Sample Corefile

```yaml
apiVersion: v1
data:
  Corefile: |
    .:53 {
        errors
        health {
           lameduck 5s
        }
        ready
        kubernetes cluster.local in-addr.arpa ip6.arpa {
           pods insecure
           fallthrough in-addr.arpa ip6.arpa
           ttl 30
        }
        prometheus :9153
        forward . /etc/resolv.conf {
           max_concurrent 1000
        }
        cache 30 {
           disable success cluster.local
           disable denial cluster.local
        }
        loop
        reload
        loadbalance
    }
kind: ConfigMap
metadata:
  name: coredns
  namespace: kube-system
```

#### The Main Block

```
.:53 {
    ...
}
```

| Part | Meaning |
|------|---------|
| `.` | Handle ALL domains (the dot means "everything") |
| `53` | Listen on port 53 (standard DNS port) |
| `{ }` | Settings inside these braces |

#### Each Directive Explained

##### 1. `errors`

```
errors
```

**"Log any errors that happen"** — Simple error logging.

##### 2. `health`

```
health {
   lameduck 5s
}
```

**"Provide a health check endpoint"**

| Part | Meaning |
|------|---------|
| `health` | Expose health check at `http://:8080/health` |
| `lameduck 5s` | When shutting down, wait 5 seconds before stopping (graceful shutdown) |

Kubernetes uses this to know if CoreDNS is healthy.

##### 3. `ready`

```
ready
```

**"Tell Kubernetes when I'm ready to serve traffic"**

Exposes endpoint at `http://:8181/ready`. Kubernetes checks this before sending DNS queries.

##### 4. `kubernetes` (The Important One!)

```
kubernetes cluster.local in-addr.arpa ip6.arpa {
   pods insecure
   fallthrough in-addr.arpa ip6.arpa
   ttl 30
}
```

**"Handle Kubernetes service discovery"**

| Part | Meaning |
|------|---------|
| `cluster.local` | Handle queries for `*.cluster.local` (your services!) |
| `in-addr.arpa` | Handle reverse DNS (IP → name) |
| `ip6.arpa` | Handle IPv6 reverse DNS |
| `pods insecure` | Allow pod DNS lookups (without verification) |
| `fallthrough` | If not found, try next plugin |
| `ttl 30` | Cache answers for 30 seconds |

**This is why `web.default.svc.cluster.local` works!**

```
┌──────────────────────────────────────────────────────────────┐
│                                                               │
│  Query: "web.default.svc.cluster.local"                      │
│                        │                                      │
│                        ▼                                      │
│  ┌─────────────────────────────────────┐                     │
│  │     kubernetes plugin               │                     │
│  │                                     │                     │
│  │  "I handle *.cluster.local"         │                     │
│  │  "Let me check Kubernetes API..."   │                     │
│  │  "Found! web service = 10.96.3.19"  │                     │
│  └─────────────────────────────────────┘                     │
│                        │                                      │
│                        ▼                                      │
│              Return: 10.96.3.19                              │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

##### 5. `prometheus`

```
prometheus :9153
```

**"Expose metrics for monitoring"**

Exposes metrics at `http://:9153/metrics` for Prometheus to scrape.

##### 6. `forward` (The Other Important One!)

```
forward . /etc/resolv.conf {
   max_concurrent 1000
}
```

**"Forward external queries to upstream DNS"**

| Part | Meaning |
|------|---------|
| `.` | For all domains (not handled by kubernetes plugin) |
| `/etc/resolv.conf` | Use DNS servers from this file (your node's DNS) |
| `max_concurrent 1000` | Handle up to 1000 queries at once |

**This is why `google.com` works from inside pods!**

```
┌──────────────────────────────────────────────────────────────┐
│                                                               │
│  Query: "google.com"                                         │
│                        │                                      │
│                        ▼                                      │
│  ┌─────────────────────────────────────┐                     │
│  │     kubernetes plugin               │                     │
│  │                                     │                     │
│  │  "Is this *.cluster.local?"         │                     │
│  │  "No → pass to next plugin"         │                     │
│  └─────────────────────────────────────┘                     │
│                        │                                      │
│                        ▼                                      │
│  ┌─────────────────────────────────────┐                     │
│  │     forward plugin                  │                     │
│  │                                     │                     │
│  │  "Forward to upstream DNS"          │                     │
│  │  "Ask 192.168.1.1 (your router)"    │                     │
│  └─────────────────────────────────────┘                     │
│                        │                                      │
│                        ▼                                      │
│              Return: 142.250.193.14                          │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

##### 7. `cache`

```
cache 30 {
   disable success cluster.local
   disable denial cluster.local
}
```

**"Cache DNS responses to speed things up"**

| Part | Meaning |
|------|---------|
| `30` | Cache for 30 seconds |
| `disable success cluster.local` | Don't cache successful Kubernetes lookups |
| `disable denial cluster.local` | Don't cache failed Kubernetes lookups |

**Why disable cache for cluster.local?**

Because services can change quickly (pods restart, scale up/down). You want fresh data, not stale cache.

##### 8. `loop`

```
loop
```

**"Detect and prevent DNS loops"**

If CoreDNS accidentally forwards to itself, this catches it and stops infinite loops.

##### 9. `reload`

```
reload
```

**"Auto-reload config when it changes"**

If you edit this ConfigMap, CoreDNS will pick up changes without restart.

##### 10. `loadbalance`

```
loadbalance
```

**"Randomize the order of DNS answers"**

If a service has multiple IPs, rotate the order to spread traffic.

#### Visual: Complete CoreDNS Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                         CoreDNS                                  │
│                                                                  │
│   Query comes in on port 53                                     │
│              │                                                   │
│              ▼                                                   │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │ 1. errors     → Log any errors                          │   │
│   │ 2. health     → Health check endpoint                   │   │
│   │ 3. ready      → Readiness endpoint                      │   │
│   │ 4. kubernetes → Is it *.cluster.local?                  │   │
│   │                 YES → Look up in Kubernetes API         │   │
│   │                 NO  → Pass to next plugin               │   │
│   │ 5. prometheus → Expose metrics                          │   │
│   │ 6. forward    → Send to upstream DNS (router/ISP)       │   │
│   │ 7. cache      → Cache results (except cluster.local)    │   │
│   │ 8. loop       → Prevent infinite loops                  │   │
│   │ 9. reload     → Auto-reload on config change            │   │
│   │ 10. loadbalance → Randomize answer order                │   │
│   └─────────────────────────────────────────────────────────┘   │
│              │                                                   │
│              ▼                                                   │
│   Return answer to pod                                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### Corefile Directives Summary

| Directive | Purpose |
|-----------|---------|
| `errors` | Log errors |
| `health` | Health check for Kubernetes |
| `ready` | Readiness check for Kubernetes |
| `kubernetes` | Handle `*.cluster.local` (service discovery) |
| `prometheus` | Expose metrics |
| `forward` | Forward external queries to upstream DNS |
| `cache` | Cache responses (disabled for cluster.local) |
| `loop` | Prevent DNS loops |
| `reload` | Auto-reload config changes |
| `loadbalance` | Distribute traffic across multiple IPs |

#### The Two Key Plugins

| Plugin | Handles | Example |
|--------|---------|---------|
| `kubernetes` | Internal cluster names | `web.default.svc.cluster.local` |
| `forward` | Everything else | `google.com`, `github.com` |

This is how pods can resolve **both** internal services AND external websites!

---

## Part 9: The Big Picture

### How Service Discovery Works

```
┌─────────────────────────────────────────────────────────┐
│                    Kubernetes Cluster                    │
│                                                          │
│  ┌──────────┐     1. "web" IP?      ┌─────────────┐     │
│  │  dnstest │ ──────────────────▶   │   CoreDNS   │     │
│  │   Pod    │                       │  10.96.0.10 │     │
│  └──────────┘  ◀──────────────────  └─────────────┘     │
│                  2. "10.96.3.19"           │            │
│                                            │            │
│  ┌──────────┐                              │            │
│  │   web    │ ◀── 3. Connect ──────────────┘            │
│  │ Service  │     to 10.96.3.19:80                      │
│  │10.96.3.19│                                           │
│  └──────────┘                                           │
└─────────────────────────────────────────────────────────┘
```

### Why This Matters

**Without DNS:** Apps would need hardcoded IPs that change when pods restart.

**With CoreDNS:** Apps just use `http://web` or `http://web.default.svc.cluster.local` — Kubernetes handles the rest.

This is how microservices find each other in Kubernetes.

---

## Part 9: Best Practices

### DNS Query Guidelines

| Scenario | Recommended Query |
|----------|-------------------|
| Same namespace | `web` (short name) |
| Cross-namespace | `web.other-namespace.svc.cluster.local` (FQDN) |
| Avoid | `web.other-namespace` (partial name - unreliable) |

### Testing DNS

```bash
# Same namespace (works)
kubectl exec dnstest -- nslookup web

# Full FQDN (always works)
kubectl exec dnstest -- nslookup web.default.svc.cluster.local

# External domains (works - CoreDNS forwards)
kubectl exec dnstest -- nslookup google.com
```

---

## References

- [kubernetes/dns Issue #118 - nslookup: can't resolve 'kubernetes.default'](https://github.com/kubernetes/dns/issues/118)
- [docker-library/busybox Issue #61 - Nslookup does not work if omitting .svc.cluster.local suffix](https://github.com/docker-library/busybox/issues/61)
- [Kubernetes Docs - Debugging DNS Resolution](https://kubernetes.io/docs/tasks/administer-cluster/dns-debugging-resolution/)
- [docker-library/busybox Issue #48 - Nslookup does not work in latest busybox](https://github.com/docker-library/busybox/issues/48)

---

## Cleanup

```bash
kubectl delete deployment web
kubectl delete service web
kubectl delete pod dnstest
```
