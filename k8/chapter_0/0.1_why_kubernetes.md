# 0.1 Why Kubernetes?

## The Problem: Deploying Applications is Hard

Let's trace the evolution of how we deploy applications:

```text
┌──────────────────────────────────────────────────────────────┐
│                 EVOLUTION OF DEPLOYMENT                      │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│   1990s: Bare Metal                                          │
│   ┌─────────────────────────────────────────┐                │
│   │  One Server = One App                   │                │
│   │  Problem: Expensive, slow, wasteful     │                │
│   └─────────────────────────────────────────┘                │
│                          ↓                                   │
│   2000s: Virtual Machines                                    │
│   ┌─────────────────────────────────────────┐                │
│   │  One Server = Many VMs = Many Apps      │                │
│   │  Problem: VMs are heavy (GB each)       │                │
│   └─────────────────────────────────────────┘                │
│                          ↓                                   │
│   2013+: Containers (Docker)                                 │
│   ┌─────────────────────────────────────────┐                │
│   │  Lightweight, fast, portable (MB each)  │                │
│   │  Problem: How do you manage 100s?       │                │
│   └─────────────────────────────────────────┘                │
│                          ↓                                   │
│   2014+: Kubernetes                                          │
│   ┌─────────────────────────────────────────┐                │
│   │  Orchestrate containers at scale        │                │
│   │  Auto-healing, scaling, rolling updates │                │
│   └─────────────────────────────────────────┘                │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

---

## The Real Problems Kubernetes Solves

### Problem 1: "It's 3 AM and the Server Crashed"

**Without Kubernetes:**

```text
Server crashes
    ↓
App is down
    ↓
PagerDuty alert at 3 AM
    ↓
You wake up, SSH in
    ↓
Restart manually
    ↓
Hope it doesn't happen again
```

**With Kubernetes:**

```text
Container crashes
    ↓
K8s detects in seconds
    ↓
K8s restarts it automatically
    ↓
You sleep peacefully
```

K8s continuously monitors your containers. If one dies, it brings up a new one automatically. This is called **self-healing**.

---

### Problem 2: "Black Friday Traffic Spike"

**Without Kubernetes:**

```text
Traffic spikes 10x
    ↓
Server overloaded
    ↓
Manually spin up more servers
    ↓
Configure load balancer
    ↓
Hope it works in time
    ↓
Traffic drops, forget to scale down
    ↓
Wasted money on idle servers
```

**With Kubernetes:**

```text
Traffic spikes 10x
    ↓
K8s auto-scales more containers
    ↓
Traffic handled smoothly
    ↓
Traffic drops
    ↓
K8s scales down automatically
    ↓
Cost optimized
```

K8s can **auto-scale** based on CPU, memory, or custom metrics.

---

### Problem 3: "Deploy Without Downtime"

**Without Kubernetes:**

```text
New version ready
    ↓
Take app offline (maintenance mode)
    ↓
Deploy new version
    ↓
Start app
    ↓
Users experienced downtime
```

**With Kubernetes:**

```text
New version ready
    ↓
K8s gradually starts new pods
    ↓
Old pods keep serving traffic
    ↓
Once new pods are healthy, traffic shifts
    ↓
Old pods terminated
    ↓
Zero downtime!
    ↓
Something wrong? K8s rolls back automatically
```

This is called a **rolling update**. K8s does it by default.

---

### Problem 4: "Works on My Machine"

**Without Kubernetes:**

```text
Works on laptop
    ↓
Deploy to server
    ↓
Different OS, libraries, configs
    ↓
App crashes
    ↓
Debug for hours
    ↓
"But it works on MY machine!"
```

**With Kubernetes:**

```text
Build container (includes everything)
    ↓
Same container runs everywhere
    ↓
Laptop = Staging = Production
    ↓
No surprises
```

Containers package your app with ALL its dependencies. K8s runs those containers consistently across any environment.

---

## What is Orchestration?

Think of an orchestra. You have 50+ musicians, each playing different instruments. Without a conductor, it would be chaos. The conductor:

- Tells each musician when to start/stop
- Coordinates timing between sections
- Handles mistakes (cues someone back in)
- Adjusts tempo as needed

**Container orchestration is the same idea for containers.**

```text
┌─────────────────────────────────────────────────────────────┐
│                    WITHOUT ORCHESTRATION                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   You manually:                                             │
│   • Start containers on different servers                   │
│   • Check if they're healthy                                │
│   • Restart crashed ones                                    │
│   • Balance load between them                               │
│   • Update them one by one                                  │
│   • Scale up when traffic increases                         │
│                                                             │
│   With 5 containers? Doable.                                │
│   With 500 containers? Impossible.                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                     WITH ORCHESTRATION                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   You say: "Run 10 copies of my app"                        │
│                                                             │
│   Orchestrator handles:                                     │
│   • WHERE to run them (which servers have capacity)         │
│   • MONITORING health (is container responding?)            │
│   • RESTARTING failures (container crashed? start new one)  │
│   • NETWORKING (how do containers find each other?)         │
│   • LOAD BALANCING (distribute traffic evenly)              │
│   • SCALING (add/remove based on demand)                    │
│   • UPDATES (replace old with new, zero downtime)           │
│                                                             │
│   5 containers or 5000? Same effort for you.                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Kubernetes is the most popular container orchestrator.** Others exist (Docker Swarm, Nomad), but K8s won the industry.

---

## What Kubernetes Actually Does

Kubernetes is a **container orchestration platform**. Think of it as a robot manager for your containers.

| You Tell K8s | K8s Does |
|--------------|----------|
| "Run 3 copies of my app" | Schedules 3 containers across your servers |
| "Keep them running" | Restarts any that crash |
| "Handle more traffic" | Adds more containers automatically |
| "Update to v2" | Gradually replaces v1 with v2, no downtime |
| "Something's wrong!" | Instantly rolls back to v1 |

---

## Declarative vs Imperative

This is a key concept in Kubernetes.

### Imperative (Old Way): Tell the system HOW

You give step-by-step commands:

```bash
# SSH into server
ssh user@server1

# Stop old version
docker stop myapp

# Pull new image
docker pull myapp:v2

# Start new version
docker run -d myapp:v2

# Repeat for server2, server3, server4...
# Hope you didn't miss any steps
```

Problems:
- Error-prone (did you remember all steps?)
- Hard to reproduce
- No record of what was done
- Different result each time

### Declarative (K8s Way): Tell the system WHAT

You describe the desired state:

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3           # I want 3 copies
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:v2  # Using version 2
```

```bash
kubectl apply -f deployment.yaml   # Make it so
```

K8s figures out the HOW:
- Which servers have capacity?
- Which containers need to stop?
- How to route traffic during update?
- What order to do things?

Benefits:
- Reproducible (same YAML = same result)
- Self-documenting (YAML IS the documentation)
- Version controlled (track changes in Git)
- Idempotent (apply 100 times, same result)

---

## The Kubernetes Promise

```text
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   "I don't care WHERE my app runs,                          │
│    I just want it RUNNING."                                 │
│                                                             │
│   K8s handles:                                              │
│   ✓ Which server to use                                     │
│   ✓ Restarting crashed containers                           │
│   ✓ Scaling up/down                                         │
│   ✓ Rolling updates                                         │
│   ✓ Load balancing                                          │
│   ✓ Service discovery                                       │
│   ✓ Secret management                                       │
│   ✓ Configuration management                                │
│                                                             │
│   You handle:                                               │
│   → Describe what you want (YAML)                           │
│   → K8s makes it happen                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## When NOT to Use Kubernetes

K8s isn't always the answer. Consider alternatives if:

| Situation | Better Option |
|-----------|---------------|
| Single small app | Simple VPS or PaaS (Render, Railway) |
| Just learning containers | Docker Compose |
| Serverless workloads | AWS Lambda, Cloud Functions |
| Tight budget, small team | Managed PaaS services |
| No DevOps experience | Start simpler, grow into K8s |

K8s adds complexity. Use it when you need:
- High availability (99.9%+ uptime)
- Auto-scaling for variable traffic
- Multiple services that need to communicate
- Zero-downtime deployments
- Multi-cloud or hybrid cloud

---

## Real-World Example: Our Job Board App

Throughout this course, we'll build a Job Board application:

```text
┌─────────────────────────────────────────────────────────────┐
│                       JOB BOARD                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Users → [Load Balancer] → [Frontend] → [Backend] → [DB]   │
│                                                             │
│   What we need:                                             │
│   - 3 frontend containers (for reliability)                 │
│   - 2 backend containers (can scale)                        │
│   - 1 database (stateful)                                   │
│   - They need to talk to each other                         │
│   - Traffic needs to be balanced                            │
│   - Updates shouldn't cause downtime                        │
│                                                             │
│   This is complex! K8s handles it all.                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Key Takeaways

1. **K8s solves operational pain** - no more 3 AM wake-ups for crashed apps
2. **Self-healing** - crashed containers restart automatically
3. **Auto-scaling** - handles traffic spikes without manual intervention
4. **Rolling updates** - deploy without downtime
5. **Declarative** - describe WHAT you want, K8s figures out HOW
6. **Not always needed** - adds complexity, use when benefits outweigh costs

---

## Check Your Understanding

Before moving on, make sure you can answer:

- [ ] What are the 4 main problems K8s solves?
- [ ] What's the difference between declarative and imperative?
- [ ] What does "self-healing" mean in K8s?
- [ ] When should you NOT use K8s?
- [ ] Why is declarative configuration better than imperative?

---

**Next:** [0.2 Kubernetes Architecture](./0.2_k8s_architecture.md)
