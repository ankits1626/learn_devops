# 0.2a Explore the API Server

> The front door to Kubernetes - every request goes through it

---

## First, What Problem Does the API Server Solve?

Imagine a cluster with 100 computers. How do you:
- Tell them all what to run?
- Ask them what's currently running?
- Make sure everyone has the same information?

**Answer: Have ONE central place that everyone talks to.**

```text
┌─────────────────────────────────────────────────────────────────┐
│                    WITHOUT API SERVER                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   You ──▶ Node 1: "Run nginx"                                   │
│   You ──▶ Node 2: "Run nginx"                                   │
│   You ──▶ Node 3: "Run nginx"                                   │
│   ...                                                           │
│   You ──▶ Node 100: "Run nginx"                                 │
│                                                                 │
│   Nightmare! What if Node 50 missed the message?                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    WITH API SERVER                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   You ──▶ API Server: "Run nginx"                               │
│                │                                                │
│                │ (API Server tells everyone)                    │
│                ▼                                                │
│           All 100 nodes get the message                         │
│                                                                 │
│   One place to talk to = simple!                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**The API Server is like a receptionist** - you tell the receptionist what you need, and they coordinate with everyone else.

---

## What is the API Server, Really?

It's a **web server**. That's it.

- It listens for HTTP requests (like any website)
- It runs on port 6443 (HTTPS)
- When you run `kubectl get pods`, kubectl sends an HTTP request to this server

```text
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   kubectl get pods                                              │
│        │                                                        │
│        │  (secretly becomes)                                    │
│        ▼                                                        │
│   HTTP GET https://api-server:6443/api/v1/pods                  │
│        │                                                        │
│        │  (API Server responds with)                            │
│        ▼                                                        │
│   JSON data listing all pods                                    │
│        │                                                        │
│        │  (kubectl formats it nicely)                           │
│        ▼                                                        │
│   NAME         READY   STATUS    AGE                            │
│   my-pod       1/1     Running   5m                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Hands-On: Find the API Server

Let's find where the API Server is running in your cluster.

```bash
kubectl get pods -n kube-system | grep apiserver
```

**What does this command mean?**
- `kubectl get pods` - List all pods
- `-n kube-system` - Only in the "kube-system" namespace (where K8s system components live)
- `| grep apiserver` - Filter to only show lines containing "apiserver"

**Output:**
```text
kube-apiserver-playground-control-plane   1/1     Running   0   2h
```

**What does this output mean?**
| Column | Value | Meaning |
|--------|-------|---------|
| NAME | `kube-apiserver-playground-control-plane` | The pod's name |
| READY | `1/1` | 1 container ready out of 1 total |
| STATUS | `Running` | It's alive and working |
| RESTARTS | `0` | Hasn't crashed |
| AGE | `2h` | Running for 2 hours |

**Key insight:** The API Server itself is just a pod running in your cluster!

---

## Now Let's Understand: What is a Namespace?

Before we go further, you keep seeing `-n kube-system`. What's a namespace?

**A namespace is like a folder** - it groups related things together.

```text
┌─────────────────────────────────────────────────────────────────┐
│                    YOUR CLUSTER                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Namespace: kube-system (Kubernetes system stuff)              │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  api-server    etcd    scheduler    controller          │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   Namespace: default (Your apps go here by default)             │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  my-app    my-database    my-redis                      │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   Namespace: production (Another folder for prod apps)          │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  prod-app    prod-db                                    │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```bash
# See all namespaces
kubectl get namespaces
```

**Output:**
```text
NAME                 STATUS   AGE
default              Active   2h
kube-node-lease      Active   2h
kube-public          Active   2h
kube-system          Active   2h
local-path-storage   Active   2h
```

- `default` - Where your pods go if you don't specify a namespace
- `kube-system` - Where Kubernetes system components live

---

## The Big Reveal: kubectl is Just an HTTP Client

Here's the key insight: **kubectl is just making web requests**.

Let me prove it to you.

### Step 1: See the Raw HTTP Request

```bash
# The -v=6 flag shows verbose output including the HTTP request
kubectl get pods -v=6
```

**Output (look for the GET line):**
```text
I0117 10:00:00.123456   12345 loader.go:395] Config loaded from file: /Users/you/.kube/config
I0117 10:00:00.234567   12345 round_trippers.go:466] GET https://127.0.0.1:6443/api/v1/namespaces/default/pods?limit=500 200 OK in 15 milliseconds
```

**What does this tell us?**

| Part | Meaning |
|------|---------|
| `GET` | HTTP method (like visiting a webpage) |
| `https://127.0.0.1:6443` | API Server address |
| `/api/v1/namespaces/default/pods` | The URL path (we'll decode this below) |
| `200 OK` | Success! |

---

## Understanding the URL Path: /api/v1/namespaces/default/pods

Let's decode this URL piece by piece:

```text
/api/v1/namespaces/default/pods
  │   │     │        │      │
  │   │     │        │      └── Resource type: pods
  │   │     │        └── Namespace name: default
  │   │     └── We're asking about namespaces
  │   └── API version: v1 (stable)
  └── Core API group
```

**It's like a file path:**
- `/api/v1` = The API version
- `/namespaces/default` = In the "default" folder
- `/pods` = Show me the pods

**Different URLs for different things:**
```text
/api/v1/pods                           → All pods in ALL namespaces
/api/v1/namespaces/default/pods        → Pods in "default" namespace
/api/v1/namespaces/kube-system/pods    → Pods in "kube-system" namespace
/api/v1/nodes                          → All nodes (not namespaced)
/api/v1/namespaces                     → List all namespaces
```

---

## Hands-On: Make Raw HTTP Requests (Like kubectl Does)

Now let's do what kubectl does - make HTTP requests directly!

### Why Does the API Server Require Authentication?

The API Server controls your **entire cluster** - it can:

- Start/stop any application
- Read secrets (passwords, API keys)
- Delete everything
- Access any data

**Would you leave your front door unlocked?**

```text
┌─────────────────────────────────────────────────────────────────┐
│                    IF API SERVER HAD NO AUTH                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Anyone who knows the address could:                           │
│                                                                 │
│   curl https://your-cluster:6443/api/v1/secrets                 │
│   → Get all your database passwords!                            │
│                                                                 │
│   curl -X DELETE https://your-cluster:6443/api/v1/pods          │
│   → Delete all your applications!                               │
│                                                                 │
│   Hackers, competitors, anyone on your network...               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

So the API Server requires **proof of identity** - like showing your ID at a secure building.

### How Does kubectl Authenticate?

When you run `kubectl get pods`, it automatically:

1. Reads `~/.kube/config` to find your credentials
2. Attaches your certificate to the HTTP request
3. API Server validates: "This certificate is trusted. Welcome!"

```text
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   kubectl get pods                                              │
│        │                                                        │
│        │  1. Read ~/.kube/config                                │
│        │  2. Get your certificate + private key                 │
│        │  3. Attach to HTTPS request                            │
│        ▼                                                        │
│   API Server: "Certificate is valid. You're kubernetes-admin.   │
│                You're allowed to list pods. Here you go!"       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Why Do We Need a Proxy?

But if we want to use `curl` (a simple HTTP tool), we'd need to pass certificates manually:

```bash
# This is what you'd have to type WITHOUT kubectl proxy:
curl --cacert /path/to/ca.crt \
     --cert /path/to/client.crt \
     --key /path/to/client.key \
     https://127.0.0.1:6443/api/v1/pods
```

That's annoying! So we use **`kubectl proxy`** - it creates a local "tunnel" that handles auth for us.

```text
┌─────────────────────────────────────────────────────────────────┐
│                    WITHOUT PROXY                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   curl ──▶ API Server                                           │
│            "Who are you? Show me your certificate!"             │
│            ❌ Rejected (401 Unauthorized)                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    WITH PROXY                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   curl ──▶ kubectl proxy ──▶ API Server                         │
│            (localhost:8080)   (adds your certificate)           │
│                               ✅ Allowed!                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Real-world analogy:**

```text
API Server = Bank vault
kubectl    = You with your ID card (automatically shows ID)
curl       = You without ID
proxy      = Your assistant who carries your ID and shows it for you
```

### Step 1: Start the Proxy

```bash
# Start a proxy on port 8080
# The & runs it in the background
kubectl proxy --port=8080 &
```

**Output:**
```text
Starting to serve on 127.0.0.1:8080
```

Now you have a local server at `localhost:8080` that forwards requests to the API Server.

### Step 2: Make Your First Raw API Call

```bash
# List pods in default namespace (same as: kubectl get pods)
curl http://localhost:8080/api/v1/namespaces/default/pods
```

**Output (JSON - this is what kubectl receives!):**
```json
{
  "kind": "PodList",
  "apiVersion": "v1",
  "items": []
}
```

**What does this mean?**
- `kind: PodList` - This is a list of pods
- `items: []` - The list is empty (no pods in default namespace yet)

### Step 3: Create a Pod So We Have Something to See

```bash
# Create a simple pod
kubectl run demo-pod --image=nginx:alpine

# Now try the API call again
curl http://localhost:8080/api/v1/namespaces/default/pods
```

**Output (truncated):**
```json
{
  "kind": "PodList",
  "apiVersion": "v1",
  "items": [
    {
      "metadata": {
        "name": "demo-pod",
        "namespace": "default"
      },
      "spec": {
        "containers": [
          {
            "name": "demo-pod",
            "image": "nginx:alpine"
          }
        ]
      },
      "status": {
        "phase": "Running"
      }
    }
  ]
}
```

**This is the raw data!** kubectl takes this JSON and formats it into the nice table you see.

### Step 4: Compare - Same Data, Different Format

```bash
# Raw JSON from API
curl -s http://localhost:8080/api/v1/namespaces/default/pods | head -20

# kubectl's formatted version of the SAME data
kubectl get pods
```

**kubectl output:**
```text
NAME       READY   STATUS    RESTARTS   AGE
demo-pod   1/1     Running   0          2m
```

**Same information, just formatted nicely!**

### Step 5: Get One Specific Pod

```bash
# Get just demo-pod (same as: kubectl get pod demo-pod -o json)
curl http://localhost:8080/api/v1/namespaces/default/pods/demo-pod
```

Notice the URL pattern:
- `/pods` = all pods
- `/pods/demo-pod` = just the pod named "demo-pod"

### Step 6: Clean Up

```bash
# Delete the demo pod
kubectl delete pod demo-pod

# Stop the proxy
pkill -f "kubectl proxy"
```

---

## Experiment: Try Without the Proxy (See It Fail)

This proves that authentication is required:

```bash
# Try to access API server directly (no proxy)
# -k means "ignore certificate warnings"
curl -k https://127.0.0.1:6443/api/v1/pods
```

**Output:**
```json
{
  "kind": "Status",
  "apiVersion": "v1",
  "status": "Failure",
  "message": "Unauthorized",
  "code": 401
}
```

**401 Unauthorized** - The API server says "I don't know who you are!"

This is why kubectl needs your `~/.kube/config` file - it contains your credentials.

---

## See Your Credentials

```bash
# Look at your kubernetes config
cat ~/.kube/config
```

**Output (simplified):**
```yaml
clusters:
- cluster:
    server: https://127.0.0.1:6443      # API Server address
    certificate-authority-data: LS0t... # Server's certificate
  name: kind-playground

users:
- name: kind-playground
  user:
    client-certificate-data: LS0t...    # Your certificate
    client-key-data: LS0t...            # Your private key

contexts:
- context:
    cluster: kind-playground
    user: kind-playground
  name: kind-playground

current-context: kind-playground        # Which context to use
```

**This file tells kubectl:**
1. WHERE the API server is (`server: https://127.0.0.1:6443`)
2. WHO you are (your certificate)
3. How to PROVE it's really the API server (certificate-authority)

---

## Summary: The Mental Model

```text
┌─────────────────────────────────────────────────────────────────┐
│                    THE SIMPLE TRUTH                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   kubectl get pods                                              │
│                                                                 │
│   Is secretly:                                                  │
│                                                                 │
│   1. Read ~/.kube/config to find API server address             │
│   2. HTTP GET https://api-server:6443/api/v1/namespaces/        │
│      default/pods                                               │
│   3. Include your certificate for authentication                │
│   4. Receive JSON response                                      │
│   5. Format JSON into a nice table                              │
│   6. Print to screen                                            │
│                                                                 │
│   That's ALL kubectl does. It's a fancy HTTP client.            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Why Does This Matter?

Understanding this helps you:

1. **Debug connection issues** - "Can't connect to cluster" = can't reach API server
2. **Understand dashboards** - Kubernetes Dashboard is just a web UI making the same API calls
3. **Build tools** - You can write scripts that call the API directly
4. **Understand security** - You know why `~/.kube/config` is important

---

## Key Takeaways

1. **API Server = Web server** - It's just HTTP requests
2. **kubectl = HTTP client** - It makes requests and formats responses
3. **URLs have meaning** - `/api/v1/namespaces/default/pods` is like a file path
4. **Authentication required** - Your `~/.kube/config` has your credentials
5. **kubectl proxy** - Creates a local tunnel that handles auth for you

---

## Quick Reference

| kubectl command | API URL |
|-----------------|---------|
| `kubectl get pods` | `GET /api/v1/namespaces/default/pods` |
| `kubectl get pods -A` | `GET /api/v1/pods` |
| `kubectl get pods -n kube-system` | `GET /api/v1/namespaces/kube-system/pods` |
| `kubectl get nodes` | `GET /api/v1/nodes` |
| `kubectl get namespaces` | `GET /api/v1/namespaces` |

```bash
# Start proxy
kubectl proxy --port=8080 &

# Make API calls
curl http://localhost:8080/api/v1/namespaces/default/pods

# Stop proxy
pkill -f "kubectl proxy"

# See what kubectl does
kubectl get pods -v=6
```

---

**Next:** [0.2b Explore etcd](./0.2b_explore_etcd.md) - Where all this data is stored
