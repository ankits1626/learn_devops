# 0.2f Explore Pods

> The smallest deployable unit - single and multi-container patterns

---

## What is a Pod?

A Pod is **NOT** a container. It's a wrapper around one or more containers that:
- Share the same network (localhost)
- Share the same storage volumes
- Are scheduled together on the same node
- Have the same lifecycle (start/stop together)

```text
┌─────────────────────────────────────────────────────────────────┐
│                        POD                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Single Container Pod (Most Common)                            │
│   ┌───────────────────────────────────────┐                     │
│   │               Pod                      │                    │
│   │   ┌───────────────────────────────┐   │                     │
│   │   │         my-app                │   │                     │
│   │   │       (container)             │   │                     │
│   │   └───────────────────────────────┘   │                     │
│   │                                        │                    │
│   │   IP: 10.244.1.5                       │                    │
│   └───────────────────────────────────────┘                     │
│                                                                 │
│   Multi-Container Pod (Sidecar Pattern)                         │
│   ┌───────────────────────────────────────┐                     │
│   │               Pod                      │                    │
│   │   ┌─────────────┐  ┌─────────────┐    │                    │
│   │   │   my-app    │  │   sidecar   │    │                    │
│   │   │ (container) │  │ (container) │    │                    │
│   │   │    :8080    │  │    :9090    │    │                    │
│   │   └─────────────┘  └─────────────┘    │                    │
│   │         │                │             │                    │
│   │         └───localhost────┘             │                    │
│   │                                        │                    │
│   │   IP: 10.244.1.6 (shared!)             │                    │
│   │   Volume: /logs (shared!)              │                    │
│   └───────────────────────────────────────┘                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Part 1: Single Container Pods

### Hands-On: Create a Simple Pod

```bash
# Imperative way (quick)
kubectl run single-pod --image=nginx:alpine

# Check it
kubectl get pods
kubectl describe pod single-pod
```

### Hands-On: Pod YAML (Declarative)

```bash
# Generate YAML without creating
kubectl run yaml-demo --image=nginx:alpine --dry-run=client -o yaml
```

Output:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: yaml-demo
  labels:
    run: yaml-demo
spec:
  containers:
  - name: yaml-demo
    image: nginx:alpine
```

Let's create a more detailed pod:

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: detailed-pod
  labels:
    app: demo
    environment: learning
spec:
  containers:
  - name: nginx
    image: nginx:alpine
    ports:
    - containerPort: 80
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "128Mi"
        cpu: "200m"
EOF

kubectl get pod detailed-pod -o wide
```

### Hands-On: Interact with Your Pod

```bash
# Get logs
kubectl logs detailed-pod

# Execute commands inside
kubectl exec detailed-pod -- ls /usr/share/nginx/html

# Get an interactive shell
kubectl exec -it detailed-pod -- sh

# Inside the container:
hostname
cat /etc/nginx/nginx.conf
exit
```

### Hands-On: Pod Networking

```bash
# Get pod IP
kubectl get pod detailed-pod -o wide

# Test connectivity from another pod
kubectl run test-pod --image=busybox --rm -it --restart=Never -- wget -qO- http://<POD-IP>
```

You should see nginx's welcome page HTML!

```bash
# Cleanup
kubectl delete pod single-pod detailed-pod
```

---

## Part 2: Multi-Container Pods

When you need containers that work closely together.

### Hands-On: Sidecar Pattern - Log Collector

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: sidecar-demo
spec:
  containers:
  # Main application
  - name: app
    image: busybox
    command: ["sh", "-c", "while true; do echo \$(date) - Hello from app >> /var/log/app.log; sleep 5; done"]
    volumeMounts:
    - name: logs
      mountPath: /var/log

  # Sidecar that reads logs
  - name: log-reader
    image: busybox
    command: ["sh", "-c", "tail -f /var/log/app.log"]
    volumeMounts:
    - name: logs
      mountPath: /var/log

  volumes:
  - name: logs
    emptyDir: {}
EOF

# Check both containers are running
kubectl get pod sidecar-demo
```

Output shows `2/2` - both containers ready!

```bash
# See logs from the main app
kubectl logs sidecar-demo -c app

# See logs from the sidecar (it's tailing the log file)
kubectl logs sidecar-demo -c log-reader
```

Both containers share the `/var/log` volume!

```bash
# Exec into specific container
kubectl exec -it sidecar-demo -c app -- sh
cat /var/log/app.log
exit

kubectl exec -it sidecar-demo -c log-reader -- sh
cat /var/log/app.log   # Same file!
exit
```

### Hands-On: Containers Share localhost

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: localhost-demo
spec:
  containers:
  # Web server on port 80
  - name: nginx
    image: nginx:alpine
    ports:
    - containerPort: 80

  # Another container that can reach nginx via localhost
  - name: tester
    image: busybox
    command: ["sh", "-c", "while true; do wget -qO- http://localhost:80 && sleep 10; done"]
EOF

# Check logs of tester - it's reaching nginx via localhost!
kubectl logs localhost-demo -c tester
```

Both containers share the same network namespace = same IP = can use localhost!

```bash
kubectl delete pod sidecar-demo localhost-demo
```

---

## Part 3: Init Containers

Containers that run BEFORE the main containers start.

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: init-demo
spec:
  initContainers:
  # First init container - runs first
  - name: init-download
    image: busybox
    command: ["sh", "-c", "echo 'Downloading config...' && sleep 5 && echo 'config data' > /data/config.txt"]
    volumeMounts:
    - name: data
      mountPath: /data

  # Second init container - runs after first completes
  - name: init-setup
    image: busybox
    command: ["sh", "-c", "echo 'Setting up...' && sleep 3 && echo 'setup complete' >> /data/config.txt"]
    volumeMounts:
    - name: data
      mountPath: /data

  containers:
  # Main container - only starts after ALL init containers complete
  - name: app
    image: busybox
    command: ["sh", "-c", "cat /data/config.txt && sleep 3600"]
    volumeMounts:
    - name: data
      mountPath: /data

  volumes:
  - name: data
    emptyDir: {}
EOF

# Watch the pod start
kubectl get pod init-demo -w
```

You'll see:
```text
init-demo   0/1     Init:0/2            0          2s
init-demo   0/1     Init:1/2            0          7s
init-demo   0/1     PodInitializing     0          12s
init-demo   1/1     Running             0          14s
```

Init containers ran in order, then main container started!

```bash
# Check what the main container sees
kubectl logs init-demo

# Output:
# config data
# setup complete

kubectl delete pod init-demo
```

---

## Part 4: Pod Lifecycle

### Pod Phases

```bash
# Create a pod and watch its phases
kubectl run phase-demo --image=nginx:alpine

kubectl get pod phase-demo -o jsonpath='{.status.phase}'
# Output: Running
```

Pod phases:
- **Pending** - Accepted but not yet running (scheduling, image pull)
- **Running** - At least one container is running
- **Succeeded** - All containers completed successfully (Jobs)
- **Failed** - All containers terminated, at least one failed
- **Unknown** - Can't determine state (node communication issues)

### Container States

```bash
kubectl get pod phase-demo -o jsonpath='{.status.containerStatuses[0].state}'
```

Container states:
- **Waiting** - Not yet running (pulling image, etc.)
- **Running** - Executing
- **Terminated** - Finished (successfully or failed)

```bash
kubectl delete pod phase-demo
```

---

## Part 5: Pod Restart Policies

What happens when a container crashes?

```bash
# Default: Always restart
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: restart-always
spec:
  restartPolicy: Always  # Default
  containers:
  - name: app
    image: busybox
    command: ["sh", "-c", "echo 'Starting'; sleep 5; exit 1"]
EOF

# Watch restarts
kubectl get pod restart-always -w
```

The container keeps restarting because `restartPolicy: Always`!

```bash
# Check restart count
kubectl get pod restart-always
# RESTARTS column increases

kubectl delete pod restart-always
```

### Never Restart (for Jobs)

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: restart-never
spec:
  restartPolicy: Never
  containers:
  - name: app
    image: busybox
    command: ["sh", "-c", "echo 'Done!'; exit 0"]
EOF

kubectl get pod restart-never -w
```

Status goes to `Completed` and stays there.

```bash
kubectl delete pod restart-never
```

---

## Part 6: Common Multi-Container Patterns

### Pattern 1: Ambassador (Proxy)

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: ambassador-demo
spec:
  containers:
  # Main app talks to localhost:6379
  - name: app
    image: busybox
    command: ["sh", "-c", "while true; do echo 'Connecting to redis at localhost:6379'; sleep 10; done"]

  # Ambassador proxies to external redis
  - name: ambassador
    image: nginx:alpine  # In real life: a proxy like envoy
    # Would proxy localhost:6379 → external-redis.example.com:6379
EOF

kubectl logs ambassador-demo -c app
kubectl delete pod ambassador-demo
```

### Pattern 2: Adapter (Transform)

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: adapter-demo
spec:
  containers:
  # App writes logs in custom format
  - name: app
    image: busybox
    command: ["sh", "-c", "while true; do echo '{\"level\":\"info\",\"msg\":\"hello\"}' >> /var/log/app.log; sleep 5; done"]
    volumeMounts:
    - name: logs
      mountPath: /var/log

  # Adapter transforms logs to standard format
  - name: adapter
    image: busybox
    command: ["sh", "-c", "tail -f /var/log/app.log | while read line; do echo \"TRANSFORMED: \$line\"; done"]
    volumeMounts:
    - name: logs
      mountPath: /var/log

  volumes:
  - name: logs
    emptyDir: {}
EOF

kubectl logs adapter-demo -c adapter
kubectl delete pod adapter-demo
```

---

## Part 7: Debugging Pods

### Pod Won't Start?

```bash
# Create a broken pod
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: broken-pod
spec:
  containers:
  - name: app
    image: nginx:nonexistent-tag
EOF

# Check status
kubectl get pod broken-pod
# Shows: ErrImagePull or ImagePullBackOff

# Get details
kubectl describe pod broken-pod | tail -20

# See events
kubectl get events --field-selector involvedObject.name=broken-pod

kubectl delete pod broken-pod
```

### Container Crashing?

```bash
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: crash-pod
spec:
  containers:
  - name: app
    image: busybox
    command: ["sh", "-c", "exit 1"]
EOF

# Check status
kubectl get pod crash-pod
# Shows: CrashLoopBackOff

# Get logs from crashed container
kubectl logs crash-pod

# Get logs from previous crash
kubectl logs crash-pod --previous

kubectl delete pod crash-pod
```

### Get a Debug Shell

```bash
# Create a normal pod
kubectl run debug-target --image=nginx:alpine

# Debug with ephemeral container (K8s 1.25+)
kubectl debug -it debug-target --image=busybox -- sh

# Or create a debug pod in same namespace
kubectl run debug-pod --rm -it --image=busybox -- sh

kubectl delete pod debug-target
```

---

## Key Takeaways

1. **Pod ≠ Container** - Pod wraps one or more containers
2. **Shared namespace** - Containers in a pod share network (localhost) and can share volumes
3. **Single container is most common** - Multi-container for specific patterns
4. **Sidecar patterns** - Log collectors, proxies, adapters
5. **Init containers** - Setup tasks before main container
6. **Lifecycle** - Pending → Running → Succeeded/Failed
7. **Restart policies** - Always, OnFailure, Never

---

## Quick Reference

```bash
# Create pod
kubectl run <name> --image=<image>

# Create from YAML
kubectl apply -f pod.yaml

# Get pods
kubectl get pods
kubectl get pods -o wide

# Describe
kubectl describe pod <name>

# Logs
kubectl logs <pod>
kubectl logs <pod> -c <container>
kubectl logs <pod> --previous

# Exec
kubectl exec -it <pod> -- sh
kubectl exec -it <pod> -c <container> -- sh

# Delete
kubectl delete pod <name>

# Debug
kubectl debug -it <pod> --image=busybox

# Generate YAML
kubectl run <name> --image=<image> --dry-run=client -o yaml
```

---

## Multi-Container YAML Template

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: multi-container
spec:
  initContainers:
  - name: init
    image: busybox
    command: ["sh", "-c", "echo init"]

  containers:
  - name: main
    image: nginx:alpine
    ports:
    - containerPort: 80
    volumeMounts:
    - name: shared
      mountPath: /data

  - name: sidecar
    image: busybox
    command: ["sh", "-c", "sleep 3600"]
    volumeMounts:
    - name: shared
      mountPath: /data

  volumes:
  - name: shared
    emptyDir: {}
```

---

**Back to:** [0.2 Architecture Overview](./0.2_architecture_overview.md)

**Next Chapter:** Chapter 1 - Pods In-Depth
